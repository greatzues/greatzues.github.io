<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="zues blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="zues blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="zues blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zues blog">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?b706031fedc2f13c7dc61b81d4a77d64";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


  <title> zues blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">zues blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/06/ES入门4/" itemprop="url">
                  ES入门4
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-08-06T10:45:49+08:00" content="2016-08-06">
              2016-08-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/06/ES入门4/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/08/06/ES入门4/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>今天学的是javascript的class，关于class基本语法，继承，构造函数，等等</p>
<h2 id="class的基本语法"><a href="#class的基本语法" class="headerlink" title="class的基本语法"></a>class的基本语法</h2><hr>
<p>javascript传统方法是通过构造函数，定义生成新的对象。如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.x = x;</span><br><span class="line">	<span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">'('</span>+<span class="keyword">this</span>.x+<span class="string">','</span>+<span class="keyword">this</span>.y+<span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>可是这样的写法和传统的面向对象难免有差异，至少我看起来这样的写法就有点陌生了。</p>
<p>ES6提供了更接近传统语音的写法，引入了class，也就是类，class的大部分功能，ES5都可以做到，我们可以将class看作是一个语法糖，只是为了程序员阅读方便而已。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(x, y)&#123;</span><br><span class="line">		<span class="keyword">this</span>.x = x;</span><br><span class="line">		<span class="keyword">this</span>.y = y;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	thString()&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到constructor，那就是传统面向对象的构造函数的英文单词了，然后this则表示实例对象。对比上下ES5和ES6可以知道ES5的<strong>构造函数</strong>对应ES6的<strong>Point类</strong>的构造<strong>方法</strong>。</p>
<p>除此之外Point类还定义了一个toString方法，这时候要注意语法结构了，不需要添加function关键字，直接把函数定义加进去就可以了。另外，方法之间不再需要逗号分隔了，反而加了之后会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typeof</span> Point <span class="comment">// "function"</span></span><br><span class="line">Point === Point.prototype.constructor <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码定义了一个类，使用typeof函数指明了Point，输出的是一个function，也就是说类的数据类型的就是函数，而最后一段代码更表明<strong>类本身就指向构造函数</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  doStuff() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'stuff'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Bar();</span><br><span class="line">b.doStuff() <span class="comment">// "stuff"</span></span><br></pre></td></tr></table></figure>
<p>使用的时候也和普通new出实例一样，直接对类使用new命令。但是构造函数的prototype属性，在ES6的类这个新特性上继续存在。而事实上，类的所有方法都定义在类的prototype属性上。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString()&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toValue()&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line">Point.prototype = &#123;</span><br><span class="line">  toString()&#123;&#125;,</span><br><span class="line">  toValue()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>哈哈，不过鉴于我还是习惯不用prototype。在类的实例上面调用方法，其实就是调用原型上的方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line">b.constructor === B.prototype.constructor <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>哈哈，学到这里突然就想起一点东西，因为ES6也出现了类，那么在类的整个块级作用域内，使用let实例定义一个变量的话，就相当于java的private关键字，只允许在会计作用内使用。<br>上面的代码中，可以看到最后一段代码表示它的constructor方法就是和B类原型的construor方法等同。</p>
<p>由于类的方法都可以定义在prototype上，所以类的新方法可以添加在prototpe对象上面。<strong>Object.assign</strong>方法可以很很方便的一次向类添加多个方法,哈哈，好像挺方便的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(Point.prototype, &#123;</span><br><span class="line">  toString()&#123;&#125;,</span><br><span class="line">  toValue()&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>prototype对象的constructor属性，直接指向类的本身，这与ES5的行为是一致的，证据如下：。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point.prototype.constructor === Point <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/05/ES入门3/" itemprop="url">
                  ES入门3
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-08-05T10:47:22+08:00" content="2016-08-05">
              2016-08-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/05/ES入门3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/08/05/ES入门3/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h1><p>因为项目进度比较赶，所以我要先跳着学了，现在直接跳到Module这一章来学。<br>首先直接看标题就知道是围绕模块化，因为ES6的class只是面向对象的语法糖，但是没有解决模块化问题。</p>
<p>ES6的模块的思想，是尽量的静态化，使得编译的时候就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> &#123; stat, exists, readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.stat, exists = _fs.exists, readfile = _fs.readfile;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码实质是整体加载fs模块（也就是加载fs的所有方法），生成一个对象_fs,然后再从这个对象上面读取3个发那个发，这种加载的方式成为“运行时加载”，因为只有运行时才能得到这个对象。</p>
<p><strong>ES6</strong>不是对象，而是通过<strong>export</strong>命令显示指定输出的代码，输入时也采用静态命令的形式。(其实我不明白这句话的意思)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码是从fs模块加载3个方法，其他方法不加载。这种加载方式称为“编译时加载”，也就是在编译的时候就会完成加载，效率要比CommonJS的要高。当然这样导致没法引用ES6模块本身，因为它不是对象，从这里可以理解到ES6不可以引用对象。</p>
<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><hr>
<p>ES6的模块自动采用严格模式，不管你是否在模块头部加上“use strict”;。<br>严格模式有以下限制：</p>
<blockquote>
<p>变量必须声明后再使用<br>函数的参数不能有同名属性，否则报错<br>不能使用with语句<br>不能对只读属性赋值，否则报错<br>不能使用前缀0表示八进制数，否则报错<br>不能删除不可删除的属性，否则报错<br>不能删除变量delete prop，会报错，只能删除属性delete global[prop]<br>eval不会在它的外层作用域引入变量<br>eval和arguments不能被重新赋值<br>arguments不会自动反映函数参数的变化<br>不能使用arguments.callee<br>不能使用arguments.caller<br>禁止this指向全局对象<br>不能使用fn.caller和fn.arguments获取函数调用的堆栈<br>增加了保留字（比如protected、static和interface）</p>
</blockquote>
<h2 id="export命令"><a href="#export命令" class="headerlink" title="export命令"></a>export命令</h2><hr>
<pre><code>模块功能主要由两个命令组成：**export和import**。&apos;export&apos;命令用于规定模块的对外接口，&apos;import&apos;用于输入其他模块提供的功能。
</code></pre><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部都无法获取。如果你希望外部能够读取模块内部的某个变量，就要使用export关键字暑输出该变量。下面代码输出了三个变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"><span class="string">``</span><span class="string">`	</span><br><span class="line">另一种写法(推荐)：</span><br><span class="line">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;firstName, lastName, year&#125;;</span><br></pre></td></tr></table></figure></p>
<p>第二种方法应该被优先考虑使用，因为这样就可以在脚本的底部一看就清楚输出了哪些变量。</p>
<p>通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。另外export还可以输出函数或者是类（class）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v1</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v2</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  v1 <span class="keyword">as</span> streamV1,</span><br><span class="line">  v2 <span class="keyword">as</span> streamV2,</span><br><span class="line">  v2 <span class="keyword">as</span> streamLatestVersion</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码使用了as关键字，重命名了函数v1和v2的对外接口，重命名之后，v2可以用不同的名字输出两次，可是我不知道输出两次的用处是什么。</p>
<p><strong>export命令规定的是对外的接口，必须与模块内部的变量建立一一对应的关系。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法一</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法二</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;m&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法三</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;n <span class="keyword">as</span> m&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> f;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;f&#125;;</span><br></pre></td></tr></table></figure></p>
<p>第一种写法直接输出1，第二种写法通过变量m，还是直接输出1，1只是一个值，不是接口。因此正确的写法应该是下面三种。</p>
<p>不过第三种写法我觉得和第二种差不多，但是确不会报错，好奇怪。其实质都是规定了对外的接口m。其他脚本可以通过这个借口取到值1.</p>
<p>同样，参考最后三种可以知道function和class的输出也遵循这样的写法。另外export语句输出的接口，与其对应的值是动态绑定的关系。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line">setTimeout(() =&gt; foo = <span class="string">'baz'</span>, <span class="number">500</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面的代码输出foo变量，值为bar，但是500毫秒之后就会变成baz。export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口可以取到模块内部实时的值。</p>
<p>export只能处于模块顶层任何位置，但是不能处于块级作用域内，也就是括号()和大括号{}内都不可以。</p>
<h2 id="import命令"><a href="#import命令" class="headerlink" title="import命令"></a>import命令</h2><hr>
<p>在使用export命令定义好模块的对外接口之后，其他的js文件就可以通过import命令加载对应的模块。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;firstName, lastName, year&#125; <span class="keyword">from</span> <span class="string">'./profile'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  element.textContent = firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码使用import命令，加载profile.js文件，并从中输入变量。import命令接受一个对象也就是{},里面指定要从其他模块导入的变量名，其变量名需要被导入的对外接口变量名相同。</p>
<p>当然也可以用as来改写名字，如下面代码所示，另外，<strong>import命令</strong>具有提升效果，会提升到整个模块的头部，首先执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; lastName <span class="keyword">as</span> surname &#125; <span class="keyword">from</span> <span class="string">'./profile'</span>;</span><br></pre></td></tr></table></figure></p>
<p>下面的代码尽管import在使用的方法后面，但是不会报错，因为import会先被执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果在一个模块内，先输入后输出同一个模块，import可以和export语句写在一起。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; es6 <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123; es6 &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> es6;</span><br></pre></td></tr></table></figure></p>
<p>但是不建议使用连在一行的写法，因为这样不利于阅读。<br>不过这里我有一个问题，那就是使用这样导出之后，对外接口的名字是什么？default还是es6？</p>
<h2 id="模块整体加载"><a href="#模块整体加载" class="headerlink" title="模块整体加载"></a>模块整体加载</h2><p>和指定加载某个模块不一样，可以用（*）号指定一个对象，所有的输出值都加载在上面。</p>
<p>假如现在有一个circle.js文件，它export两个方法area和circumstance。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">circumference</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">Math</span>.PI * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们来加载这个模块到main.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; area, circumference &#125; <span class="keyword">from</span> <span class="string">'./circle'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆面积：'</span> + area(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆周长：'</span> + circumference(<span class="number">14</span>));</span><br></pre></td></tr></table></figure></p>
<p>然后我们也可以使用这一节介绍的方法将所有导出的函数加载进去，写法参考下面的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'./circle'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆面积：'</span> + circle.area(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆周长：'</span> + circle.circumference(<span class="number">14</span>));</span><br></pre></td></tr></table></figure></p>
<p>这里我还有一个疑问，那就是为什么不直接import  * from ‘./circle’呢，当然这里我可以理解为实例化了circle对象来调用circle.js里面的方法。</p>
<h2 id="export-default命令"><a href="#export-default命令" class="headerlink" title="export default命令"></a>export default命令</h2><p>紧张，我刚刚还在疑问这个命令的用法，没想到就开始介绍到了。</p>
<p>从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p>
<p>为了给用户方便，使用户不用阅读就能加载模块，于是export就应运而生了，为模块指定默认输出，也就是不需要明显生成输出接口就默认需要输出，这对于我来联想java就可以想象到java的接口的应用，也是有一些使用abstract抽象化的接口是必须要实现的，我觉得差不多，仅仅是觉得而已。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假设上面的代码是模块文件export-default.js.它输出的是一个函数。其他模块加载这个模块的时候，import命令可以为该匿名函数指定任意名字。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'./export-default'</span>;</span><br><span class="line">customName(); <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure></p>
<p>值得注意的是，上面的import命令可以用任意名称指向export-default.js模块输出的方法，而这时候就就不需要知道原模块输出的函数名，并且此时不需要使用<strong>大括号</strong>。</p>
<p>‘export default’命令用在匿名函数前，也是可以得。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者写成</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，使用default输出之后，在模块的外部是无效的，加载的时候视同匿名函数加载。</p>
<p>下面通过代码比较一下默认的输出和正常情况下的输出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="keyword">import</span> crc32 <span class="keyword">from</span> <span class="string">'crc32'</span>;</span><br><span class="line"><span class="comment">//--------------》》此处是分界线》》----------------</span></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="keyword">import</span> &#123;crc32&#125; <span class="keyword">from</span> <span class="string">'crc32'</span>;</span><br></pre></td></tr></table></figure></p>
<p>和下午需要讲到的一样，此时我也已经想到一件事，那就是，那假如一个模块里面如果有两个默认输出那该怎么办，很好，如果此时你想到这个的时候就不用顾虑了，因为ES6中，一个模块只允许有一个默认的输出。</p>
<p>本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法也是有效的，不过繁琐了一点，但是理解起来会比较容易一点。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;add <span class="keyword">as</span> <span class="keyword">default</span>&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// export default add;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> xxx &#125; <span class="keyword">from</span> <span class="string">'modules'</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// import xxx from 'modules';</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码有一处地方值得被发现，那就是’export default add;’，根据注释，很明显知道这句代码的含义是将函数（有时候是变量）add的值赋给变量default。因此我们看下一段的代码，看上去像是正确的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>但是由于default已经赋值过了，这时候再赋值就重复了，因此会报错。</p>
<p>如果想在一条import语句中，同时输出默认方法和其他变量，就可以写成下面这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> customName, &#123; otherMethod &#125; <span class="keyword">from</span> <span class="string">'./export-default'</span>;</span><br></pre></td></tr></table></figure></p>
<p>哈哈，react-native的第一句就是和这句差不多，当时一直不理解为什么第一个react会没有大括号，现在明白了。</p>
<p>如果需要输出默认的值，只需将值跟跟在export default之后即可，这里可以相信到一些应用场景，假如某一段任务实现之后，返回true或者是其他的默认值，想想就觉得蛮有作用的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">42</span>;</span><br></pre></td></tr></table></figure></p>
<p>前面也已经提到过一点，export可以输出一个类class，export default也可以实现。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> MyClass <span class="keyword">from</span> <span class="string">'MyClass'</span>;</span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> MyClass();</span><br></pre></td></tr></table></figure></p>
<p>最后是一个例子，输入jQuery，不过我不怎么懂那个’$’符号是什么意思，我自己的理解就是仅仅是一个custom name，仅仅而已，不管，先标记一下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>;</span><br></pre></td></tr></table></figure></p>
<p>最后，真的是最后，我还有一个疑问，就是加入使用’export *’来导出所有输出的时候，那么是不是默认的也输出了呢！假如输出了，那么输出之后的接口名字是什么？</p>
<h2 id="模块的继承"><a href="#模块的继承" class="headerlink" title="模块的继承"></a>模块的继承</h2><p>模块之间可以继承。假设有一个circleplus模块，继承了circle模块：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circleplus.js</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'circle'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> e = <span class="number">2.71828182846</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.exp(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>竟然那么快又看到答案了，不过我上面的那个问题后半段问得有点傻逼，加入输出之后对应的接口名字就在import了改模块之后自定义了啊！天哪，又犯老糊涂了。</p>
<p>不过上面这段代码中的’export <em>‘,表示输出circle也就是父类的所有属性和方法，但是’export </em>‘会忽略circle模块的default方法。然后，上面的代码又输出了circleplue自定义的e变量和默认方法。</p>
<p>对应需要加载上面的模块写法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> math <span class="keyword">from</span> <span class="string">'circleplus'</span>;</span><br><span class="line"><span class="keyword">import</span> exp <span class="keyword">from</span> <span class="string">'circleplus'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(exp(math.e));</span><br></pre></td></tr></table></figure></p>
<p>结合前面写的东西就可以知道上面代码中的’import exp’表示，将circleplus模块的默认方法加载为exp方法。</p>
<p>剩下还有ES6模块加载的实质，还有好多好多。暂时不写先，想睡觉了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/02/ES6入门2/" itemprop="url">
                  ES6入门2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-08-02T15:32:41+08:00" content="2016-08-02">
              2016-08-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/02/ES6入门2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/08/02/ES6入门2/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="变量的解构复制"><a href="#变量的解构复制" class="headerlink" title="变量的解构复制"></a>变量的解构复制</h1><hr>
<h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5为变量赋值</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//ES6为变量赋值，允许下面这样</span></span><br><span class="line"><span class="keyword">var</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>同样的赋值，ES6能节省更多代码，其中最后一行代码表示从数组中取值，按照对应的位置，对变量赋值。<br>这种写法被称作“模式匹配”，也就是只要等号两边的模式相同，左边的变量就会被赋予对应的值，下面是使用嵌套数组进行解构的例子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];</span><br><span class="line">third <span class="comment">// "baz"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head <span class="comment">// 1</span></span><br><span class="line">tail <span class="comment">// [2, 3, 4]</span></span><br><span class="line">tail[<span class="number">2</span>] <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</span><br><span class="line">x <span class="comment">// "a"</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br></pre></td></tr></table></figure></p>
<p>对于上面的运行结果我得思考一下，如果两边刚好有对应的，那么久赋值到对应的值，不过竟然可以用第二种和第三中方式进行赋值，觉得有点神奇，尽管这种赋值方式并不现实。相比之下，第四种方式更实用一点，通过字符<strong>…</strong>声明一个数组存储对应后面的很多值，并且额可以通过<strong>数值名字[对应数字]</strong>正常调用数组元素。这也为最后一种方式做铺垫。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [foo] = [];</span><br><span class="line"><span class="keyword">var</span> [bar, foo] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>上面的代码都表示的是解析不成功的，foo的值都等于undefined。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line">d <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>不完全解构，即等号左边的模式只匹配一部分等号右边的数组，这种情况下，解构依然能成功。正如上面的代码一样，都属于不完全解构。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>很明显左边和右边的模式是不一样的，官方的解释是因为右边的值，要么转化为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式），科普一下，Iterator是迭代器的意思，java中也有这个概念，把他想象成现代化容器，这个容器具备很多供自身被访问的功能，也就是提供遍历自身的各种抽象接口详，情自己去查阅这方面的知识。</p>
<pre><code>解构复制不仅适用于var，还适用于let和const命令。
</code></pre><p>对于Set结构，也可以使用数组的解构赋值。（记住写法）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]);</span><br><span class="line">x <span class="comment">// "a"</span></span><br></pre></td></tr></table></figure></p>
<p>现在可以用专业一点的概括语言来总结一下，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值，也就是写习惯了之后两边对称，那其实就可以了。<br>不过很尴尬，我还是不明白下面这段代码的意思：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line">sixth <span class="comment">// 5 为什么输出的是5？</span></span><br></pre></td></tr></table></figure></p>
<h3 id="这里先标记一下，真的没看懂，哈哈！！"><a href="#这里先标记一下，真的没看懂，哈哈！！" class="headerlink" title="这里先标记一下，真的没看懂，哈哈！！"></a>这里先标记一下，真的没看懂，哈哈！！</h3><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><hr>
<p>解构赋值允许默认值，例如<strong>var [foo = true] = [];</strong>，那么在调用foo的时候默认就是true，下面代码是其他例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]; <span class="comment">// x='a', y='b'</span></span><br><span class="line">[x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>]; <span class="comment">// x='a', y='b'</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>但是有一种情况是，如果有一个数组的成员是null，那么默认值就不会生效，因为null不严格等于undefined。<br>假如默认值是一个表达式，那么这个表达式是惰性求值，也就是需要用到的时候才会取值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure></p>
<p>上面的代码其实等价于下面的代码，不过我却没看懂，解释是因为x能取到值，所以函数f根本不会执行，初看以为自己理解了，但是看下面的代码却好像还是挺懵懂的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line"><span class="keyword">if</span> ([<span class="number">1</span>][<span class="number">0</span>] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  x = f();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  x = [<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再看一下下面的几个变量定义，我觉得我会弄混掉。最后一个表达式在上一章已经说过，因为x在取值y之前，y未被声明。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];     <span class="comment">// x=1; y=1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>];    <span class="comment">// x=2; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x=1; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];     <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure></p>
<h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><hr>
<p>解构除了用于数组，还用于对象。不过我觉得这样使用会把代码变得比较冗长。</p>
<p>另外对象与数组还有不同的地方，那就是数组是按照次序排列的，变量的取值由他们的位置决定，但是对象的属性没有次序，变量必须和属性同名，才能取到正确的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; foo, bar &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">foo <span class="comment">// "aaa"</span></span><br><span class="line">bar <span class="comment">// "bbb"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; baz &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">baz <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">//如果变量名与属性名字不一致，就要写成下面这样</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; first: <span class="string">'hello'</span>, last: <span class="string">'world'</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; first: f, last: l &#125; = obj;</span><br><span class="line">f <span class="comment">// 'hello'</span></span><br><span class="line">l <span class="comment">// 'world'</span></span><br></pre></td></tr></table></figure></p>
<p>其实对象的解构是下面代码形式的简写，也就是对象的解构要先找到同名属性，然后赋值给对应的变量，看下面的代码自己理解。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; foo: foo, bar: bar &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; foo: baz &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">baz <span class="comment">// "aaa"</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码中真正被复制的变量是baz，而不是模式foo。</p>
<p>再看一下下面两段代码的对比<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo;</span><br><span class="line"><span class="keyword">let</span> &#123;foo&#125; = &#123;foo: <span class="number">1</span>&#125;; <span class="comment">// SyntaxError: Duplicate declaration "foo"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> baz;</span><br><span class="line"><span class="keyword">let</span> &#123;bar: baz&#125; = &#123;bar: <span class="number">1</span>&#125;; <span class="comment">// SyntaxError: Duplicate declaration "baz"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------》》我是分界线》》-------------------</span></span><br><span class="line"><span class="comment">//仅仅是用来对比</span></span><br><span class="line"><span class="keyword">let</span> foo;</span><br><span class="line">(&#123;foo&#125; = &#123;foo: <span class="number">1</span>&#125;); <span class="comment">// 成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> baz;</span><br><span class="line">(&#123;bar: baz&#125; = &#123;bar: <span class="number">1</span>&#125;); <span class="comment">// 成功</span></span><br></pre></td></tr></table></figure></p>
<p>可以看出，采用这种写法的时候，变量的声明和赋值时一体的，也就是在一条代码就搞定了，如果像分界线上面的代码就会因为重复声明而导致报错，着对于let和const来说都是不可以的。而var命令是允许重复声明的，所以var声明是被允许的。<br>分界线下面的代码中let命令下面一行的圆括号是必须的，否则会报错。因为在解析的时候会把括号当成是代码块，而不是赋值语句处理。</p>
<p>啊啊啊！！！还有好多啊，不想看了，直接实战了，不懂再倒回来看。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/31/ES6入门/" itemprop="url">
                  ES6入门
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-07-31T16:40:00+08:00" content="2016-07-31">
              2016-07-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/31/ES6入门/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/07/31/ES6入门/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>我是在学习react-native官网的时候说开发react-native需要用到ES6的时候才开始学的，一切都还是刚刚开始，我标记一下我是在<a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">阮一峰老师的书</a>中学习的，非常棒的一本书，习惯看书学习的同学可以自己去买一本来看，链接之后就有购买途径了。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p>ES6是ECMAScript 6.0的简称，也是javascript的下一代标准，尽管这套标准目前还没有在所有的浏览器上完整实现，所以目前而言web开发中还很少使用，但是React Native内置了对ES2015(也就是ES6)标准的支持，你可以放心使用而无需担心兼容性问题。</p>
<h2 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h2><hr>
<p>先看一段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  let a = 10;</span><br><span class="line">  var b = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a // ReferenceError: a is not defined.</span><br><span class="line">b // 1</span><br></pre></td></tr></table></figure></p>
<p>我们能看到注释，在代码快使用var和let声明两个变量，在代码块外调用，let声明的变量报错而var声明的会返回正确的值。这也能看出，let声明的变量只在它所在的代码块有效。</p>
<p>因此我们可以使用let命令写for循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; arr.length; i++) &#123;&#125;</span><br><span class="line"></span><br><span class="line">console.log(i);</span><br><span class="line">//ReferenceError: i is not defined</span><br></pre></td></tr></table></figure></p>
<p>可以看到在循环体外log是会报错的。再看下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 10</span><br></pre></td></tr></table></figure></p>
<p>for循环的i是var声明的，在全局范围内有效，每一次循环都会覆盖旧的值，因此最后输出的是最后一轮的i值。而使用let的话，最后输出的是6，那为什么会是6呢！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 6</span><br></pre></td></tr></table></figure></p>
<p>因为在每一次for循环中，每一次的i都只会在该次循环中存在并且有效，而循环结束到下一次循环开始，又会进行let i = i + 1的操作，从而跳出该次循环，但是同时又重新为i赋了一个值。导致最后的数组a[]方法在每一次循环生成不同的function。</p>
<pre><code>不管是用let还是var声明，变量都要在声明后使用，否则就会报错。
</code></pre><h3 id="暂时性死区（temporal-dead-zone，简称TDZ）"><a href="#暂时性死区（temporal-dead-zone，简称TDZ）" class="headerlink" title="暂时性死区（temporal dead zone，简称TDZ）"></a>暂时性死区（temporal dead zone，简称TDZ）</h3><p>如果在局部代码块中使用<strong>let</strong>和<strong>const</strong>命令，这些区块就会形成封闭作用域，在变量声明之前使用这些变量就会报错，尽管可能在代码块外面已经用var声明过同名变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var tmp = 123;</span><br><span class="line"></span><br><span class="line">if (true) &#123;</span><br><span class="line">  tmp = &apos;abc&apos;; // ReferenceError</span><br><span class="line">  let tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  // TDZ开始</span><br><span class="line">  tmp = &apos;abc&apos;; // ReferenceError</span><br><span class="line">  console.log(tmp); // ReferenceError</span><br><span class="line"></span><br><span class="line">  let tmp; // TDZ结束</span><br><span class="line">  console.log(tmp); // undefined</span><br><span class="line"></span><br><span class="line">  tmp = 123;</span><br><span class="line">  console.log(tmp); // 123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有些死区比较难以被发现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function bar(x = y, y = 2) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); // 报错</span><br></pre></td></tr></table></figure></p>
<p>因为在参数里面声明的x直接就调用y，而y此时还没被声明。因此这时候调用bar()就会报错，其实我写这个例子主要是不明白为什么在调用bar的时候不用带参，我写java的时候如果函数有参的话调用的时候也要带参，不管，我先标记一下！！！<br>反正不管怎样就是要先声明在使用变量就对了。</p>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var tmp = new Date();</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  console.log(tmp);</span><br><span class="line">  if (false) &#123;</span><br><span class="line">    var tmp = &quot;hello world&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); // undefined</span><br></pre></td></tr></table></figure>
<p>上面代码执行之后会输出undefined，因为变量提升，导致内层tmp覆盖外层的tmp。但是这里我的重心是这段代码是不是写错了，if()的false参数怎样传进去，如果不传进去怎么执行里面的函数，好奇怪，又得标记一下了。</p>
<p>第二种场景，用来计数的循环变量泄露为全局变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;hello&apos;;</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">  console.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(i); // 5</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p>
<h3 id="ES6的块状作用域"><a href="#ES6的块状作用域" class="headerlink" title="ES6的块状作用域"></a>ES6的块状作用域</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码最后输出5，表示let声明的变量外层代码块不受内层代码块的影响，但是使用var定义变量n，也就是把两个let都变成var，最后输出10.上面同一段代码我尝试了四种情况</p>
<blockquote>
<p>用let声明第一个n，用let声明第二个n，输出的是：5<br>用let声明第一个n，用var声明第二个n，输出的是：无任何输出结果<br>用var声明第一个n，用var声明第二个n，输出的是：10<br>用var声明第一个n，用let声明第二个n，输出的是：5<br>可以看出不允许将let放在比var等级更高的代码层，不然会报错。<br>
至于ES允许的块级作用域任意嵌套，**{{{{{let insane = 'Hello World'}}}}};**，我觉得没什么用处，但是可以知道一些，这时候外层作用域无法读取内层作用域的变量。
不过也正是块级作用域的出现，就可以逐渐淘汰掉现在被广泛使用的匿名函数(IIFE)不再必要了
undefined

块级作用域与函数声明
在ES6中，允许在块级作用域中声明函数，而这在ES5之前是不被允许的，规定函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。
undefined

很重要的一点是，ES6规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。
undefined

上面代码中，会得到“i am inside!”，因为在if内声明的函数f会被提升到函数头部。
> * 允许在块级作用域内声明函数。
> * 函数声明类似于var，即会提升到全局作用域或函数作用域的头部
> * 同时，函数声明还会提升到所在的块级作用域的头部

注意：上面三条规则只对ES6的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。

前面的代码在老版本的chrome环境在运行时会报错的。
因为在老版的chrome环境下被编译的时候会被解释成。
undefined

因为考虑到环境导致的行为差异太大，应避免在块级作用域内声明函数。加入确实需要也应该写成函数表达式，而不是声明语句。
undefined

另外，还有一个需要注意的地方。ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。
undefined

</p>
<h2 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h2><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。哈哈，记忆的时候就可以将这个词和我们java的final一起记忆了。<br>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo;</span><br><span class="line"><span class="comment">// SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>上面的代码表示，对于const一旦表明变量，就必修立即初始化，不能留到以后赋值，不然就会报错。</p>
<blockquote>
<ul>
<li>const的作用域与let命令相同：只在声明所在的块级作用域内有效。</li>
<li>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</li>
<li>const声明的常量，也与let一样不可重复声明。</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">foo.prop</span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">foo = &#123;&#125;; <span class="comment">// TypeError: "foo" is read-only</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，常量foo存储的是一个地址，这个地址指向一个对象。不可变的这个地址，而最后一句代码foo = {}相当于把foo指向另一个地址，于是就会报错，但那时对象本身是可变的，所以可以为期添加新属性。<br>下面是另一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.push(<span class="string">'Hello'</span>); <span class="comment">// 可执行</span></span><br><span class="line">a.length = <span class="number">0</span>;    <span class="comment">// 可执行</span></span><br><span class="line">a = [<span class="string">'Dave'</span>];    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，常量a是一个数组，这个数组本身是可以写的，但是如果将另一个数组赋值给a，就会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></span><br><span class="line"><span class="comment">// 严格模式时，该行会报错</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中使用了一个<strong>Object.freeze</strong>方法，将常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式下还会报错。</p>
<p>除了将对象本身冻结，对象的属性也可以被冻结，虽然我不知福冻结的用法在什么情况下会被用到。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constantize = (obj) =&gt; &#123;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach( (key, value) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span> ) &#123;</span><br><span class="line">      constantize( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>扩展</strong>：ES5只有两种声明变量的方法：var命令和function，命令。ES6除了添加let和const命令之外，还有其他声明变量的方法：import和class命令，而这些也是我要写react-native需要用到的，因此ES6一共会有6中声明变量的方法。</p>
<h3 id="全局对象的属性"><a href="#全局对象的属性" class="headerlink" title="全局对象的属性"></a>全局对象的属性</h3><p>全局对象是最顶层的对象，在浏览器环境指的是window对象，在nodejs中指的是global对象。ES5之中，全局对象的属性和全局变量是等价的,就像下面的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">1</span>;</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，全局对象的属性赋值和全局变量的赋值，被看做事同一件事（对于Node来说，这一条只对REPL环境适用，模块环境之中，全局变量必须显式声明成global对象的属性。这句不太明白，还是先标记一下以后明白之后再改正！！）</p>
<p>到了ES6之后就开始改变了，为了保持兼容性，var命令和function命令声明发的全局变量，依旧是全局变量的属性，另外有let命令，const命令class命令声明的全局变量，不属于全局变量的属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在Node的REPL环境，可以写成global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成this.a</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，全局变量a由var命令声明，所以他是全局变量的属性；而全局变量b由let声明，所以它不是全局变量的属性，返回undefined(未定义)。</p>
<p>终于看完这一章了，好多知识点啊！！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/31/react-native学习笔记2/" itemprop="url">
                  react-native学习笔记2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-07-31T10:45:15+08:00" content="2016-07-31">
              2016-07-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/31/react-native学习笔记2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/07/31/react-native学习笔记2/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="编写Hello-World"><a href="#编写Hello-World" class="headerlink" title="编写Hello World"></a>编写Hello World</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; AppRegistry, Text &#125; from &apos;react-native&apos;</span><br><span class="line"></span><br><span class="line">class HelloWorldApp extends Component &#123;</span><br><span class="line">	render() &#123;</span><br><span class="line">		return (</span><br><span class="line">			&lt;Text&gt;Hello World!&lt;/Text&gt;</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//注意，这里用引号括起来的&apos;HelloWorldApp&apos;必须和你init创建的项目名一致</span><br><span class="line">AppRegistry.registerComponent(&apos;HelloWorldApp&apos;, () =&gt; HelloWorldApp);</span><br></pre></td></tr></table></figure>
<p>然后一个简单的HelloWorldApp就完成了，不过鉴于第一次接触，所以要一步一步来分析每一步的意义。</p>
<p>首先需要了解上面的代码是我曾经学过的语言javascript，但是很明显这和我想象中javascript不像好不好，不过这确实是“未来”的javascript，最新的javascript官方标准是ES2015（也叫做ES6）.没错，在完全进行开发之前我还需要了解一下ES6.</p>
<p>简单看了一些ES6之后就要开始真干了，</p>
<h2 id="官网文档"><a href="#官网文档" class="headerlink" title="官网文档"></a>官网文档</h2><hr>
<p>官网的文档都是英文的，部分看不太懂，因为中文网最近不知道为什么突然就跪了，然后就只能对着官网的代码自己敲然后自己去翻译文档。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Sample React Native App</span><br><span class="line"> * https://github.com/facebook/react-native</span><br><span class="line"> * @flow</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; AppRegistry,  Image, Text, View, StyleSheet &#125; from &apos;react-native&apos;;</span><br><span class="line"></span><br><span class="line">class AwesomeProject extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    let pic = &#123;</span><br><span class="line">      uri: &apos;https://upload.wikimedia.org/wikipedia/commons/d/de/Bananavarieties.jpg&apos;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;View style = &#123;styles.container&#125;&gt;</span><br><span class="line">        &lt;Text&gt;hello wrold!&lt;/Text&gt;</span><br><span class="line">        &lt;Image source = &#123;pic&#125; style = &#123;&#123;width:193, height: 110&#125;&#125; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Greeting text=&apos;jsakdhkjasdh&apos; /&gt;</span><br><span class="line">        &lt;Greeting text = &apos;mike&apos; /&gt;</span><br><span class="line">        &lt;Greeting text = &apos;zues&apos; /&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Greeting extends Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;showText: true&#125;;</span><br><span class="line"></span><br><span class="line">    setInterval(() =&gt; &#123;</span><br><span class="line">      this.setState(&#123;showText: !this.state.showText &#125;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render ()&#123;</span><br><span class="line">    let display = this.state.showText ? this.props.text : &apos;&apos;;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Text&gt;&#123;display&#125;&lt;/Text&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const styles = StyleSheet.create(&#123;</span><br><span class="line">  container: &#123;</span><br><span class="line">    alignItems:&apos;center&apos;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">AppRegistry.registerComponent(&apos;AwesomeProject&apos;, () =&gt; AwesomeProject);</span><br></pre></td></tr></table></figure></p>
<p>这是在前两节的基础上，copy的第三节文档的代码。我想分析一下整理一下思路。首先是写好的class Greeting组件，这里的语法都是ES6的新语法，还好我及时恶补了一些。</p>
<p>首先是constructor构造函数，传入属性props，第一段代码就继承了父类的属性<code>super(props);</code>,然后先设定初始状态的成员变量showText为true。然后使用一个定时器作为开关，设定在1000毫秒内执行第一个参数来改变this.state.showText的值<code>this.setState({showText: !this.state.showText });</code>，然后就在render函数那里创建一个变量display存储一个判断的方法：<code>this.state.showText ? this.props.text : &#39;&#39;;</code>，代码的意思是如果this.state.showText如果为true的时候就显示this.props.text属性，否则就显示空字符。然后返回由<text>包裹的文字。</text></p>
<p>在这中间我尝试过修改了this.state为this.st或者是修改showText为show。但是修改之后效果就没有了，所以我初步断定this.state和showText为父类的属性和变量，因此不可以被修改。不过应该也可以理解，那就是在这些步骤之前使用了super关键字。</p>
<h2 id="关于style"><a href="#关于style" class="headerlink" title="关于style"></a>关于style</h2><hr>
<p>学到style的时候有开始模仿代码了，这次是样式的编写。类似官网的文档，模仿了下面的一段代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; AppRegistry,  Image, Text, View, StyleSheet &#125; from &apos;react-native&apos;;</span><br><span class="line"></span><br><span class="line">class AwesomeProject extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    let pic = &#123;</span><br><span class="line">      uri: &apos;https://upload.wikimedia.org/wikipedia/commons/d/de/Bananavarieties.jpg&apos;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;View style = &#123;styles.container&#125;&gt;</span><br><span class="line">        &lt;Text&gt;hello wrold!&lt;/Text&gt;</span><br><span class="line">        &lt;Image source = &#123;pic&#125; style = &#123;&#123;width:193, height: 110&#125;&#125; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Greeting text=&apos;jsakdhkjasdh&apos; /&gt;</span><br><span class="line">        &lt;Greeting text = &apos;mike&apos; /&gt;</span><br><span class="line">        &lt;Greeting text = &apos;zues&apos; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;LotIOfStyles /&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Greeting extends Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;showText: true&#125;;</span><br><span class="line"></span><br><span class="line">    setInterval(() =&gt; &#123;</span><br><span class="line">      this.setState(&#123;showText: !this.state.showText &#125;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render ()&#123;</span><br><span class="line">    let display = this.state.showText ? this.props.text : &apos;haha&apos;;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Text&gt;&#123;display&#125;&lt;/Text&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LotIOfStyles extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;View&gt;</span><br><span class="line">        &lt;Text style = &#123;styles.red&#125;&gt;just red&lt;/Text&gt;</span><br><span class="line">        &lt;Text style = &#123;styles.bigblue&#125;&gt;just bigblue&lt;/Text&gt;</span><br><span class="line">        &lt;Text style = &#123;[styles.bigblue, styles.red]&#125;&gt;bigblue, then red&lt;/Text&gt;</span><br><span class="line">        &lt;Text style = &#123;[styles.red, styles.bigblue]&#125;&gt;red, then bigblue&lt;/Text&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const styles = StyleSheet.create(&#123;</span><br><span class="line">  container: &#123;</span><br><span class="line">    alignItems:&apos;center&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  red: &#123;</span><br><span class="line">    color: &apos;red&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  bigblue: &#123;</span><br><span class="line">    color: &apos;blue&apos;,</span><br><span class="line">    fontWeight: &apos;bold&apos;,</span><br><span class="line">    fontSize: 30,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">AppRegistry.registerComponent(&apos;AwesomeProject&apos;, () =&gt; AwesomeProject);</span><br></pre></td></tr></table></figure></p>
<p>其实就是自己加了一个LotIOfStyles的类，然后再里面编写一些样式，读懂代码是没问题的，就是有一些小错会犯，在这里我要记下来提醒一下自己。</p>
<blockquote>
<ul>
<li>首先是styles的red和bigblue的大括号后面忘记写”,”这个小符号了，然后就是除了数字，其他的颜色和加粗之类的东西需要用<code>&#39;&#39;</code>这个符号来标识，经常会写成<code>&quot;&quot;</code>这个符号。</li>
<li>然后就是在写好四个<text>之后忘记用一个父类<view>包裹起来，这个很关键，我觉得后续我还会继续犯这个错，因为我暂时还没有完全学会这个语言。</view></text></li>
</ul>
</blockquote>
<h2 id="Height-and-Width"><a href="#Height-and-Width" class="headerlink" title="Height and Width"></a>Height and Width</h2><hr>
<p>一个组件的高度和宽度决定了组件在屏幕的尺寸。<br>最简单设置组件的宽度和高度的方法就是直接用内联样式将宽度和高度加进去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class FixedDimensionsBasics extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;View&gt;</span><br><span class="line">        &lt;View style = &#123;&#123;width: 50, height: 50, backgroundColor:&apos;powderblue&apos;&#125;&#125; /&gt;</span><br><span class="line">        &lt;View style = &#123;&#123;width: 100, height: 100, backgroundColor:&apos;skyblue&apos;&#125;&#125; /&gt;</span><br><span class="line">        &lt;View style = &#123;&#123;width: 150, height: 200, backgroundColor:&apos;steelblue&apos;&#125;&#125; /&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AppRegistry.registerComponent(&apos;AwesomeProject&apos;, () =&gt; FlexDimensionsBasics);</span><br></pre></td></tr></table></figure></p>
<p>这样就可以构造出三个小正方形了。</p>
<h2 id="Flexbox布局"><a href="#Flexbox布局" class="headerlink" title="Flexbox布局"></a>Flexbox布局</h2><hr>
<p>在React Native中使用flexbox规则来指定组件子元素的布局，Flexbox可以在不同的屏幕上提供一致的布局结构。但是一般情况下，使用<code>flexDirection</code>,<code>alignItems</code>,<code>justifyContent</code>三个样式就可以满足大部分的布局需求咯。</p>
<blockquote>
<p>React Native中的Flexbox的工作原理和web上的CSS基本一致，当然也存在少许差异。首先是默认值不同：flexDirection的默认值是column而不是row，alignItems的默认值是stretch而不是flex-start，以及flex只能指定一个数字值。</p>
</blockquote>
<h3 id="Flex-Direction"><a href="#Flex-Direction" class="headerlink" title="Flex Direction"></a>Flex Direction</h3><p>在组件的style中指定flexDirection可以决定布局的主轴。子元素可以是沿<strong>水平轴（row）</strong>方向排列，也可以是沿<strong>竖直轴（column）</strong>方向排列，而默认是竖直轴方向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class FlexDirectionBasics extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      // 尝试把`flexDirection`改为`column`看看</span><br><span class="line">      &lt;View style=&#123;&#123;flex: 1, flexDirection: &apos;row&apos;&#125;&#125;&gt;</span><br><span class="line">        &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: &apos;powderblue&apos;&#125;&#125; /&gt;</span><br><span class="line">        &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: &apos;skyblue&apos;&#125;&#125; /&gt;</span><br><span class="line">        &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: &apos;steelblue&apos;&#125;&#125; /&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AppRegistry.registerComponent(&apos;AwesomeProject&apos;, () =&gt; FlexDirectionBasics);</span><br></pre></td></tr></table></figure></p>
<p>这时候我发现了一个东西，身为初学者的我总是希望发现一些可以利用的知识点，很明显这里最后一句代码交代了这个项目（app）的名字叫做AwesomeProject，而入口组件则是FlexDirectionBasics。这就非常清晰明了了，以前我总以为要名字对应，现在才发现参数的实在意义。</p>
<h3 id="Justify-Content"><a href="#Justify-Content" class="headerlink" title="Justify Content"></a>Justify Content</h3><p>在组件的style中指定<code>justifyContent</code>可以决定其子元素沿着主轴的排列方式。子元素是应该靠近主轴的起始段还是末尾段分布呢？亦或应该是均匀分布呢？对应的这些可选项有：<code>flex-start</code>,<code>center</code>,<code>flex-end</code>,<code>space-around</code>以及<code>space-between</code>。不过其实这些我都看过教学视频，只不过当时没记下来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class JustifyContentBasics extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      // 尝试把`justifyContent`改为`center`看看</span><br><span class="line">      // 尝试把`flexDirection`改为`row`看看</span><br><span class="line">      &lt;View style=&#123;&#123;</span><br><span class="line">        flex: 1,</span><br><span class="line">        flexDirection: &apos;column&apos;,</span><br><span class="line">        justifyContent: &apos;space-between&apos;,</span><br><span class="line">      &#125;&#125;&gt;</span><br><span class="line">        &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: &apos;powderblue&apos;&#125;&#125; /&gt;</span><br><span class="line">        &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: &apos;skyblue&apos;&#125;&#125; /&gt;</span><br><span class="line">        &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: &apos;steelblue&apos;&#125;&#125; /&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>修改之后会出现几种情况，在英文官网的文档内修改也可以直接看到实时的效果，我实在本地编辑器修改测试的。</p>
<blockquote>
<p>一开始出现三个小正方形块上中下分别有一小块图像<br>修改justifyContent为center之后就变成三块合并在最左边中间<br>保留第二步不动，修改flexDirection之后就变成三块合并贴在最顶端的中间。</p>
</blockquote>
<p>因此大概可以猜到这些样式的用法了，我觉得以后经常使用会非常熟练，所以现在暂时还是测试一下不认真记录了。</p>
<h3 id="Align-Items"><a href="#Align-Items" class="headerlink" title="Align Items"></a>Align Items</h3><p>在组件的style中指定<code>alignItems</code>可以决定其子元素沿着次轴（与主轴垂直的轴，比如主轴此时为row，那么次轴就是column）的排列方式。子元素是应该靠近次轴的起始端还是末尾段分布呢？亦或应该均匀分布？对应的这些可选项有：<code>flex-start</code>、<code>center</code>、<code>flex-end</code>以及<code>stretch</code>。</p>
<p><strong>注意啦：</strong>要使stretch生效的话，子元素在次轴方向上不能有固定的尺寸。以下面的代码为例：只有将子元素样式中的<code>width：50</code>去掉之后，<code>alignItems:&#39;stretch&#39;</code>才会生效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class AlignItemsBasics extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      // 尝试把`alignItems`改为`flex-start`看看</span><br><span class="line">      // 尝试把`justifyContent`改为`flex-end`看看</span><br><span class="line">      // 尝试把`flexDirection`改为`row`看看</span><br><span class="line">      &lt;View style=&#123;&#123;</span><br><span class="line">        flex: 1,</span><br><span class="line">        flexDirection: &apos;column&apos;,</span><br><span class="line">        justifyContent: &apos;center&apos;,</span><br><span class="line">        alignItems: &apos;center&apos;,</span><br><span class="line">      &#125;&#125;&gt;</span><br><span class="line">        &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: &apos;powderblue&apos;&#125;&#125; /&gt;</span><br><span class="line">        &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: &apos;skyblue&apos;&#125;&#125; /&gt;</span><br><span class="line">        &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: &apos;steelblue&apos;&#125;&#125; /&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>三个尝试我觉得我以后能一下子看懂，主要是上面的注意，我觉得需要备注一下，因为这里的主轴方向是flexDirection是column（竖），所以次轴就是row（行），因此对应次轴的属性就是宽度不能有固定尺寸，相反，如果这时候主轴方向是row，那么子元素的宽度不能固定才能使stretch生效。</p>
<h2 id="预热"><a href="#预热" class="headerlink" title="预热"></a>预热</h2><hr>
<p>这个是看视频的时候抄的代码，觉得在刚学习的阶段应该会有用，所以先写下来记忆一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;script type =  /&gt;</span><br><span class="line">		&lt;script type =  /&gt;</span><br><span class="line">		&lt;script type =  /&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div id = &quot;example&quot;&gt;&lt;/div&gt;</span><br><span class="line">		&lt;script type = &quot;text/bable&quot;&gt;</span><br><span class="line">			var Parent = React.create(&#123;</span><br><span class="line">				click:function()&#123;</span><br><span class="line">					this.refd.child.getDOMNode().style.color=&quot;red&quot;;</span><br><span class="line">				&#125;,</span><br><span class="line">				render:function()&#123;</span><br><span class="line">					return (</span><br><span class="line">						&lt;div onClick=&#123;this.click&#125; &gt;Parents is:</span><br><span class="line">						&lt;Child name = &#123;this.props.name&#125; ref = &quot;child&quot; &gt;&lt;/child&gt;</span><br><span class="line">						&lt;/div&gt;</span><br><span class="line">					);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			</span><br><span class="line">			var Child = React.createClass(&#123;</span><br><span class="line">				render:function()&#123;</span><br><span class="line">					return &lt;span&gt; &#123;this.props.name&#125; &lt;span&gt;;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			</span><br><span class="line">			ReactDOM.render(&lt;Parent name = &quot;React语法基础&quot; /&gt; , document.getElementById(&apos;example&apos;));</span><br><span class="line">		&lt;/script&gt;		</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码不是react-native,而是react，不过还是可以先学习一下代码里面对于父类和子类之间的通信关系。<br>首先看child，代码很简单就是在渲染的时候直接返回一个span标签，里面是child的名字属性。<br>然后是父类，首先是创建一个click函数，暂时先不分析方法里面的细节，再看render函数，创建了一个div函数，并且在div的onClick方法中嗲用click函数。接着是直接使用child实例标签，这个实例里面含有一个那么的属性，关于属性的赋值是this.props.name，注意，这里认真一想还是很好理解的，那就是这个this是指向parent的，因此这里是先的到parent的name属性再赋值给child实例，这样一来就清晰很多了。<br>另外可以看到ref，我们可以把这个属性看成是标签作用，用来标记一个实例，我觉得可以把ref看成是id，回到click函数，函数里面的详细内容是this.refs.child.getDOMNode(),this.refs是找到有ref属性的实例，然后指向已经标记的实例，也就是child，刚刚命名的那个。去到对应的DOM节点，之后就可以对这个实例进行方法或者样式的变换了。这里是直接更改child的颜色，当然也可以写一个函数。</p>
<p>更加详细的属性列表<a href="http://reactnative.cn/docs/0.31/layout-props.html" target="_blank" rel="external">布局样式属性</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/29/正则表达式笔记/" itemprop="url">
                  正则表达式笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-07-29T17:46:27+08:00" content="2016-07-29">
              2016-07-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/29/正则表达式笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/07/29/正则表达式笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>正则表达式是为了记录文本规则的代码，在编写处理字符串或者网页的时候，经常会查找符合某些复杂规则的字符串而生。</p>
<p>首先举个例子，当我们需要查找某一个目录下的Word文档，我们会搜索<strong>*</strong>.doc，而这里的*就会变解释成任意的字符串，但是这里的<strong>*</strong>或者经常使用的<strong>?</strong>我们称做通配符。ok，开始学习</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><hr>
<p>假如我们需要在一边小说中查找一个单词“he”，一般情况下会怎么做呢？在我看来不管在什么情况下，我们都可以使用<strong>ctrl+f</strong>就会弹出查找的框。不过有时候比较糟糕的是很多单词都会有这两个字母，例如hello，head，heel等等，那么这时候就会有很多的he被找出来了，那当我们会使用正则表达式的话就可以使用<strong>\bhe\b</strong>.<br><strong>\b</strong>是正则表达式里面规定的一个特殊的代码，人称<strong>元字符</strong>，代表的那次的开头或者结尾，也就是单词的分界处。</p>
<p>假如这里he的后面不远处有一个Lucy，就可以使用<strong>\bhe\b.*\bLucy\b</strong>。<br>可以注意这里的<strong>.</strong>，它也是一个元字符，匹配除了换行符意外的任意字符。<strong>*</strong>同样是元字符，不过它代表的不是字符，也不是位置，而是指<strong>数量</strong>，它指定<strong>*</strong>号前边的内容可以连续重复使用任意次以使整个表达式得到匹配。<br>因此，<strong>.*</strong>就意味着<strong>任意数量的不包含换行的字符</strong>。那么现在<strong>\bhe\b.*\bLucy\b</strong>的意思就非常明显了：先是一个单词he，然后是任意字符串（不含换行）最后是lucy这个单词</p>
<p>这时候就可以联想肯定还有很多元字符，如果将其全部构造在一起那将是最强大的正则表达式。例如下面的例子：<br><strong>0\d\d-\d\d\d\d\d\d\d\d</strong>能匹配怎样的字符串呢：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字，我们的国家的电话号码就是这样的区号。<br>这里的<strong>\d</strong>是一个新的元字符，匹配一个<strong>数字</strong>（数字0-9）.但是这里的“-”号不是元字符，它只匹配一个符号，为了简便和避免出错，我们也可以用<strong>0\d{2}-\d{8}</strong>，{8}（或者{2}）表示连续重复。把<strong>{n}</strong>放在了\d前面，也就意味着前面的\d符号必须连续重复n次，相当于被copy了n次，于是就构造出了和上面区号一样的效果。</p>
<h3 id="小总结："><a href="#小总结：" class="headerlink" title="小总结："></a>小总结：</h3><blockquote>
<ul>
<li>元字符<strong>\b</strong>，代表着单词的口头或者结尾，记住是单词，而不是字符，它只匹配一个位置。</li>
<li>元字符<strong>.</strong>，匹配除了换行符以外的任意字符，记住只是单个字符。</li>
<li>元字符<strong>*</strong>，匹配的不是字符，也不是位置，肯定不能和别人抢饭碗对吧，所以它匹配的是数量，任意数量，它指定它前面的内容可以连续使用任意次从而使整个表达式得到匹配。</li>
<li>元字符<strong>\d</strong>，匹配的也是数量，但是这里它可以控制字符串多少，第一种比较傻，使用多少个“\d”就匹配多少个，而“\d{n}”，n是多少就能匹配多少次<strong>连续</strong>且重复。</li>
</ul>
</blockquote>
<h2 id="认识更多"><a href="#认识更多" class="headerlink" title="认识更多"></a>认识更多</h2><hr>
<p><strong>\ba\w*\b</strong>，首先看到\b就知道可以匹配以字母a开头的单词，然后是<strong>\w*</strong>，\w这个元字符的作用是可以匹配单个字母数字下划线或者汉字，和数量<strong>**相结合后就相当于任意数量的字母或者数字，最后\b是字母的结尾处。
</strong>\d+<strong>，可以匹配一个或更多连续的</strong>数字<strong>。这里的+是和<em>类似的元字符，不同的是不同的是</em>匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。
</strong>\b\w{6}\b**，可以匹配刚好6个字符的单词。</p>
<h3 id="常用元字符"><a href="#常用元字符" class="headerlink" title="常用元字符"></a>常用元字符</h3><table>
<thead>
<tr>
<th>代码</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td style="text-align:right">匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td>\w</td>
<td style="text-align:right">匹配字母或数字或下划线或汉字</td>
</tr>
<tr>
<td>\s</td>
<td style="text-align:right">匹配任意的空白符</td>
</tr>
<tr>
<td>\d</td>
<td style="text-align:right">匹配数字</td>
</tr>
<tr>
<td>\b</td>
<td style="text-align:right">匹配单词的开始或结束</td>
</tr>
<tr>
<td>^</td>
<td style="text-align:right">匹配字符串的开始</td>
</tr>
<tr>
<td>$</td>
<td style="text-align:right">匹配字符串的结束</td>
</tr>
</tbody>
</table>
<p>关于<strong>^</strong>和<strong>$</strong>令我有点蛋疼，因为\b也是可以匹配开头，不过这个是单词，但是^是匹配字符串，那也就是意味着^匹配的范围会更大，不过精确程度肯定是\b，另外这两个元字符还可以在允许处理多行的情况下变成匹配行的开始处和结尾处。<br>先来看一个表达式：<strong>^\d{5,12}$</strong>，这个表达式可以类似一个网站验证qq号，并且qq号必须为数字的重复次数不少于5次，不能多于12次。否则都匹配不成功。这里的<strong>{5，12}</strong>和前面\b的一样，意味着<strong>重复的次数不能少于5次，不能多于12次</strong>。</p>
<h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><hr>
<p>当我们需要查找的是正则里面的元符本身的话，正常情况下肯定找不到，这时候就要用<strong>\</strong>来消除这些字符的特殊意义，因此需要找.或者<em>的时候就要用.和\</em>。当然需要找<strong>\</strong>本身也需要使用\，因此在以后可以看到一些\\这样类型的，表示的是\。<br>例如：deerchao.net匹配deerchao.net，C:\Windows匹配C:\Windows。</p>
<h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><hr>
<p>前面已经知道了<em>表示前边的内容可以连续重复使用任意次以使整个表达式得到匹配，而+是和</em>类似但是匹配的次数重复1次或者更多，意味着一定会重复。另外{n}还有{5，12}我就不解释了，这个比较好记。</p>
<h3 id="常用的限定符"><a href="#常用的限定符" class="headerlink" title="常用的限定符"></a>常用的限定符</h3><table>
<thead>
<tr>
<th>代码/语法</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td style="text-align:right">重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td style="text-align:right">重复一次或更多次</td>
</tr>
<tr>
<td>?</td>
<td style="text-align:right">重复零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td style="text-align:right">重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td style="text-align:right">重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td style="text-align:right">重复n到m次</td>
</tr>
</tbody>
</table>
<p>例子：Windows\d+匹配Windows后面跟1个或更多数字，^\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)。</p>
<h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><hr>
<p>如果需要查找单个数字，字母都是比较简单的，但是如果需要找一些集合的时候，例如元音字母aeiou的时候怎么办，这时候只需要在方括号里面列出它们就可以了，就像这样[aeiou]就能匹配任何一个英文元音字母，[.?!]匹配标点里面的符号，从这里也可以看出在方括号里面是可以放元字符的，而无须转义。<br>当然也可以指定一个字符范围，[0-9]这个的含义就是和\d一样了：表示一个数字。同样这个例子[a-z0-9A-Z]，其实一开始我是没有看懂的，这里我们把里面的字符分开来看就可以看到a-z,0-9,A-Z这样就等同于\w了。</p>
<p>接下来是一个更加复杂的表达式：(?0\d{2}[) -]?\d{8}<br>这个表达式可以匹配集中格式的电话号码，像(010)88886666，或022-22334455，或02912345678等，对立面的字符进行分析，首先是转义的<strong>(</strong>，因为“（”和“）”都是元字符，它可能重复0次或者1次（？），然后是一个数字0，后面接着两个数字（\d{2}）,然后是方括号里面有-或者空格（要看到是有空格的）或者是“）”，也是出现一次或者零次，最后是8个重复的\d,也就是后面接着8个数字。</p>
<h2 id="分支条件"><a href="#分支条件" class="headerlink" title="分支条件"></a>分支条件</h2><hr>
<p>在上面的例子中是不是会出现一种情况，那就是假如是010)12345678或(022-87654321也是可以的，但是格式不是我们想要的，要解决这个问题需要使用到这节的标题。使用符号<strong>|</strong>把不同的规则分开，然后满足其中一种就可以完成匹配。<br>0\d{2}-\d{8}|0\d{3}-\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)<br>(?0\d{2})?[- ]?\d{8}|0\d{2}[- ]?\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。</p>
<p>\d{5}-\d{4}|\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用<strong>分枝条件时</strong>，要<strong>注意各个条件的顺序</strong>。如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。<br>对于上面一段话我有一点想法，那就是在分支匹配的时候要吧负责的匹配放在前面。不然的话复杂里面夹杂着简单的匹配的时候就会出现部分满足导致匹配不理想。还有就是<strong>|</strong>分支符号的左右都是完整的表达式，因此写这个的时候会显得和上面的方括号麻烦一些。</p>
<h2 id="分组-子表达式"><a href="#分组-子表达式" class="headerlink" title="分组/子表达式"></a>分组/子表达式</h2><hr>
<p>在前面我们知道了怎么重复单个字符，也就是前面那张表。但是如果需要重复多个字符的时候应该怎么办呢！这时候就要使用到标题，用小括号()来指定<strong>子表达式</strong>，然后就可以制定子表达式的重复次数。<br>(\d{1,3}.){3}\d{1,3}，这是一个ip地址的表达式，要理解这个表达式，我们一个一个来分析：既然是子表达式，所以肯定先分析括号里面的表达式，\d{1,3}匹配至少重复1到3位的数字，那么(\d{1,3}.){3}就是表示三位数字加一个英文句号（用了转义）重复三次，最后再加一个至少重复一次或者三次的数字（\d{1,3}）。<br>但是像上面的表达式避免不了匹配类似错误的ip256.300.888.999，因为正则没有提供关于数学的功能，因此需要冗长的表达式才可以正确描述：((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5])<br>可以发现最主要的分析对象是2[0-4]\d|25[0-5]|[01]?\d\d?，因为ip是1-255的，所以需要有几种情况，第一个分支2[0-4]，就是200-249，一看就看明白了，第二个分支25[0-5]，就是250-255，第三个分支有点难度[01]?\d\d?，意思是0或者1可能重复1次或者0次（不出现），后面接一个0-9的数字，再后面接着最多出现1次或者0次（不出现）的数字，也就是可以构造出两位数。</p>
<h2 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h2><hr>
<p>有时候需要找除了某一个字符以外的其他字符，于是这时候就要使用到反义。我个人觉得这样的情况很少见，除非一篇文章都差不多使用那么几种字符</p>
<h3 id="常用的反义字符"><a href="#常用的反义字符" class="headerlink" title="常用的反义字符"></a>常用的反义字符</h3><table>
<thead>
<tr>
<th>代码/语法</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\W</td>
<td style="text-align:right">匹配任意不是字母，数字，下划线，汉字的字符</td>
</tr>
<tr>
<td>\S</td>
<td style="text-align:right">匹配任意不是空白符的字符</td>
</tr>
<tr>
<td>\D</td>
<td style="text-align:right">匹配任意非数字的字符</td>
</tr>
<tr>
<td>\B</td>
<td style="text-align:right">匹配不是单词开头或者结束的位置</td>
</tr>
<tr>
<td>[^x]</td>
<td style="text-align:right">匹配除了x以外的任意字符</td>
</tr>
<tr>
<td>[^aeiou]</td>
<td style="text-align:right">匹配除了aeiou这几个字母以外的任意字符</td>
</tr>
</tbody>
</table>
<p>例子：\S+匹配不包含空白符的字符串，因为\S匹配不是空白符，而+要求至少要有重复，加在\S后面表示，不能有一个空白符或者多个空白符，理解下来就是没有任何空白符的<strong>字符串</strong>。<a[^>]+&gt;匹配用尖括号括起来的以a开头的字符串。<br><a[^>]+&gt;匹配用尖括号括起来的以a开头的字符串，这里需要注意尖括号不是元字符，所以就直接理解就可以了，而a[^&gt;]+表示a开头的字符串，并且a后面匹配除了&gt;符号的字符串，最后再加上最后那一个尖括号，于是就成为了用尖括号括起来的以a开头的字符串。</a[^></a[^></p>
<h2 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h2><hr>
<p>我的理解是通过后向对于已经被解释过的分组进行数字替代。用于重复搜索前面某个分组匹配的文本。例如， \1代表分组1匹配的文本。<br>例如：<strong>\b(\w+)\b\s+\1\b</strong>，可以用来匹配重复的单词，例如 go go，或者是kitty kitty。这个表达式先是一个单词，也就是单词开头和结尾处之间多余一个字母或数字的（\b(\w+)\b），这个单词在组号分配的时候会被捕获到编号为1的分组，然后是1个或几个空白符\s+，最后是分组1中捕获的内容。<br>除了可以自动陪匹配组号，还可以指定子表达式的组号，可以使用这样的语法：(?<word>\w+)(或者把尖括号换成’也是可以得:(?’Word’\w+))，这样就可以把\w+的组名指定为Word了，当需要反向指定这个分组的时候就可以使用\k<word>，所以上一个例子也可以写成这样：\b(?<word>\w)\b\s+\k<word>\b。)</word></word></word></word></p>
<p>为什么分组会从1开始呢！因为分组0对应的是整个正则表达式，而不是某一个分组，当然这里还有一个规则，就像上面说的除了那些没有命名被自动赋名的分组，还有已经被命名的分组，而组号分配是从左到右扫描两边，第一遍只给未命名组分配，第二次只给命名组分配，那么久可以很简单推测出所有命名组的组号都大于为命名组号。</p>
<h3 id="常用分组语法"><a href="#常用分组语法" class="headerlink" title="常用分组语法"></a>常用分组语法</h3><table>
<thead>
<tr>
<th>分类</th>
<th style="text-align:right">代码/语法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>捕获</td>
<td style="text-align:right">(exp)</td>
<td style="text-align:center">匹配exp,并捕获文本到自动命名的组里</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">(?<name>exp)</name></td>
<td style="text-align:center">匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">(?:exp)</td>
<td style="text-align:center">匹配exp,不捕获匹配的文本，也不给此分组分配组号</td>
</tr>
<tr>
<td>——</td>
<td style="text-align:right">——</td>
<td style="text-align:center">——–</td>
</tr>
<tr>
<td>零宽断言</td>
<td style="text-align:right">(?=exp)</td>
<td style="text-align:center">匹配exp前面的位置</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">(?&lt;=exp)</td>
<td style="text-align:center">匹配exp后面的位置</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">(?!exp)</td>
<td style="text-align:center">匹配后面跟的不是exp的位置</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">(?&lt;!exp)</td>
<td style="text-align:center">匹配前面不是exp的位置</td>
</tr>
<tr>
<td>—–</td>
<td style="text-align:right">—-</td>
<td style="text-align:center">——–</td>
</tr>
<tr>
<td>注释</td>
<td style="text-align:right">(?#comment)</td>
<td style="text-align:center">这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td>
</tr>
</tbody>
</table>
<p>例如可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权，其中exp是一个表达式，有效阻断组号分配，不过为什么要剥夺呢？我暂时还没有想到应用场景。</p>
<h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><hr>
<p>断言也就是可以预测位置，和\b,^,$一样具有指定位置的功能，并且这个位置具备一定的条件，在左边表示是前面，而在右边则是后面后面会一直持续提到这两个位置，因此被称作零宽断言。</p>
<p>(?=exp)也叫做<strong>零宽都正预测先行断言</strong>，它能断言<strong>表达式exp前面的位置</strong>。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分除ing以外，加入查找I’m singing while you’re dancing.时，它会匹配sing和danc。</p>
<p>(?&lt;=exp)也叫做<strong>零宽度正回顾后发断言</strong>，它能断言<strong>表达式exp后面的位置</strong>。比如(?&lt;=\bre)\w+\b会匹配以re开头的单词的后半部分除re以外，例如在查找reading a book时，它能匹配ading。</p>
<p>假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?&lt;=\d)\d{3})+\b，用它对1234567890进行查找时结果是234567890。<br><strong>说实话，上面这句话没看懂</strong>,不过还是可以分析：首先是分组里面的是匹配表达式\d后面的位置，然后是匹配三个数字(\d{3}),然后又是一个分组表示至少重复一次(+)，最后是就是结尾字符(\b)。<br>最后是是下面这个例子同时使用了这两种断言：(?&lt;=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。</p>
<h2 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h2><hr>
<p>负向零宽断言正好和零宽断言相反，也分为先行和回顾断言两种。<br>零宽度负预测先行断言(?!exp),意思是断言此位置的后面不能匹配表达式exp。例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字。\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。同理很好理解接下来的。</p>
<p>零宽度负回顾后发断言(?&lt;!exp),意思是断言此位置的前面不能匹配表达式exp，(?&lt;![a-z])\d{7}匹配前面不是小写字母的七位数字。我觉得以后每次看都可能需要思考一下，因为一下子有可能理解不了。</p>
<p>我们来看一下一个例子，<strong>\b\w<em>q[^u]\w</em>\b</strong>，这个表达式可以匹配一个不含换行符的单词，在前面已经知道任意数量的字母或数字是(\w<em>)，按正常情况下是可以的，但是在一些特殊情况下，例如Iraq,Benq，因为[^u]肯定会匹配一个字符，因此加入q是最后一个字符的话就会出现两个单词连在一起匹配结果。<br>但是使用了我们的负向零宽断言就不一样了，因为它完全不会消费任何字符，只匹配一个位置，因此可以使用这个表达式来轻松搞定：**\b\w</em>q(?!u)\w<em>\b*</em>,只要u前面不是q的话，那么表达式成立，同时匹配不成功</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><hr>
<p>我觉得直接看例子就可以看明白了，</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/27/python爬虫日记/" itemprop="url">
                  python爬虫日记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-07-27T16:26:12+08:00" content="2016-07-27">
              2016-07-27
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/27/python爬虫日记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/07/27/python爬虫日记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/27/学习javascript有感-2/" itemprop="url">
                  学习javascript有感-2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-07-27T10:51:44+08:00" content="2016-07-27">
              2016-07-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/27/学习javascript有感-2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/07/27/学习javascript有感-2/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="事件function"><a href="#事件function" class="headerlink" title="事件function"></a>事件function</h2><hr>
<p>事件也是面向对象开发中的一个环节，javascript的强大功能肯定少不了事件的实现。</p>
<h2 id="function作为参数"><a href="#function作为参数" class="headerlink" title="function作为参数"></a>function作为参数</h2><hr>
<p>首先看一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a,b,fn</span>)</span>&#123;</span><br><span class="line">	fn(a,b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a,b,fn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span>(fn) == <span class="string">"function"</span>)&#123;</span><br><span class="line">		fn(a,b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test(<span class="number">3</span>,<span class="number">4</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(a+b);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//输出7</span></span><br></pre></td></tr></table></figure></p>
<p>记得在调用test的时候直接用<strong>test(arguments);</strong>就可以了</p>
<h2 id="设计一个时间对象"><a href="#设计一个时间对象" class="headerlink" title="设计一个时间对象"></a>设计一个时间对象</h2><p>目标：设计一个事件对象。实现添加监听，移除监听，清空监听，发起事件信号。思路：1，定义一个对象，包含一个实例成员listeners，用于记录所有的监听者；2，为对象的原型增加，新增，删除，清空和执行四个成员。<br>整理好之后就可以具体来实现了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myEvent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.listeners = [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加一个监听者</span></span><br><span class="line">myEvent.prototype.addListener = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.listeners.push(fn)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//移除一个监听者</span></span><br><span class="line">myEvent.prototype.removeListener = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> index = <span class="keyword">this</span>.insteners.indexOf(fn);</span><br><span class="line">	<span class="keyword">this</span>.listeners.splice(index,<span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//清除所有监听者</span></span><br><span class="line">myEvent.prototype.clearListeners = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.listeners = [];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//发出执行信号，并告知所有监听者</span></span><br><span class="line">myEvent.prototype.raise = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> l = <span class="keyword">this</span>.listeners.length;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">		<span class="keyword">this</span>.listeners[i](e); <span class="comment">//执行所有监听方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me = <span class="keyword">new</span> myEvent();</span><br><span class="line">me.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">document</span>.write(<span class="string">"我是第一个监听者："</span> + e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">me.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">document</span>.write(<span class="string">"我是第二个监听者："</span> + e);</span><br><span class="line">&#125;);</span><br><span class="line">me.raise(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure></p>
<p>代码输出的结果是：<br>我是第一个监听者 : a<br>我是第二个监听者 : a</p>
<p>我先写出我开始明白的一些东西，一不小心google了一下，知道了<strong>push()</strong>的用法，直接调用w3c的解释：push() 方法可把它的参数顺序添加到 arrayObject 的尾部。它直接修改 arrayObject，而不是创建一个新的数组。push() 方法和 pop() 方法使用数组提供的先进后出栈的功能。<br>也就是可以不断在一开始的空集合listeners添加object，这也很好理解上一篇的其中一段代码的执行含义了。</p>
<p>另外就是移除一个监听者的成员方法里面的两段代码也需要解释一下，首先要科普一下indexOf和splice分别的用法。</p>
<blockquote>
<ul>
<li>indexOf(searchvalue,fromindex)，此方法可以返回字符串首次出现的位置，其中searchvalue表示要检索的字符串值，而fromindex表示从字符串的哪个位置开始检索，如果检索的字符串没有出现，则返回-1。</li>
<li>splice(index,howmany,item1,…..,itemX)，此方法可以从数组添加或者删除项目，然后返回被删除的项目。index表示添加或者删除项目的位置，使用附属可以从数组结尾处规定位置。howmany 必需。规定应该删除多少元素。如果设置为0则不进行删除操作，item1,…..,itemX分别表示想数组添加元素.<br>所以在上面的代码块中</li>
</ul>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/25/学习javascript有感/" itemprop="url">
                  学习javascript有感
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-07-25T16:14:04+08:00" content="2016-07-25">
              2016-07-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/25/学习javascript有感/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/07/25/学习javascript有感/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>基础的东西我就不想记在我的博客里面上了，大家也可以在w3c里面自己练习一下，我主要是为了记一下现在刚刚学习完javascript的思维方式，因为学好的东西一般情况下基础的东西会记得，但是总会得了新伤就忘记久痛，忘记以前学习的心得。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><hr>
<h3 id="javascript的try-catch语法"><a href="#javascript的try-catch语法" class="headerlink" title="javascript的try-catch语法"></a>javascript的try-catch语法</h3><p>在javasscript中，使用try-catch语句的用法：在try里面将可能出现抛出的错误做个判断，然后做出对应的throw信息，并会将这个信息传递给err这个变量，然后在catch(err)语句里面做相应的处理。</p>
<h3 id="javascript的原始对象"><a href="#javascript的原始对象" class="headerlink" title="javascript的原始对象"></a>javascript的原始对象</h3><p>javascript是一门面向对象的语言，因此我可以将很多知识和我现有知道的java语言相对比。在面向对象中，最重要的是封装。直接看代码<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var worker = new Object();</span><br><span class="line">worker.name = "tom";</span><br><span class="line">worker.age = 10;</span><br><span class="line">worker.isWorking = false;</span><br><span class="line">worker.startWork = function()&#123;</span><br><span class="line">	if(this.isWorking) return;</span><br><span class="line">    this.isWorking = true;</span><br><span class="line">&#125;;</span><br><span class="line">worker["position"] = "worker";</span><br><span class="line"></span><br><span class="line">document.write("Worker的名字是 : " + worker["name"]);</span><br><span class="line">worker.startWork();</span><br><span class="line">document.write("<span class="tag">&lt;<span class="name">br</span>/&gt;</span>Worker的职位是 : " + worker.position);</span><br></pre></td></tr></table></figure></p>
<p>上面这段代码输出的结果是：<br>    Worker的名字是 : tom<br>    Worker的职位是 : worker<br>再看一下另外一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> worker = &#123;</span><br><span class="line">        name : <span class="string">"John"</span>,</span><br><span class="line">        age : <span class="number">30</span>,</span><br><span class="line">        isWorking : <span class="literal">false</span>,</span><br><span class="line">        startWork : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">this</span>.isWorking)&#123;</span><br><span class="line">                <span class="keyword">this</span>.isWorking = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p>
<p>在上面的两段代码可以看出构建一个object和我们java是很不一样的，它们不需要再额外的声明一个变量来存储这个object的属性，另外和java一样的是也可以在实例里面添加字符，数字，布尔值甚至是一个方法的成员，这个特点在上面两段代码中都很明显的显示了出来。</p>
<p>在第一段代码中能发现创建属性的两种方式分别是<strong>实例名.成员名 = 内容</strong>,当然可以用<strong>实例名.[“成员名”] = 内容</strong>。而这里思想我觉得可以和java的map联系起来，就是通过键值对来存储属性，使用的时候javascript通过键解释对应的值。</p>
<p>不过认真看一下代码就知道，上面的单纯创建实例很呆板，仅仅是创建好一个可以吃的月饼，但是我们创建实例是为了方便我们后面的开发，所以这种方法肯定不提倡，我们应该创建以一个做月饼的模板，当相同的面团来的时候就可以直接用模板做好一个月饼，省去很多开发成本。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newHuman</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">    	name : name,</span><br><span class="line">        age : age,</span><br><span class="line">        sayHello : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        	<span class="built_in">document</span>.write(<span class="string">"Hello World! I'm "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h = newHuman(<span class="string">"jim"</span>,<span class="number">30</span>);</span><br><span class="line">h.sayHello(); <span class="comment">//输出结果是：Hello World! I'm jim</span></span><br></pre></td></tr></table></figure></p>
<p>这段代码声明了三个属性，分别是name，age，sayHello方法，最后实例化这个方法，调用里面的sayHello方法，当然在再外部使用实例好的h.age也是可以得。至于为什么要直接return才可以创建成员我就不知道了，用一句老话说应该是：javascript就规定这样。我试过在return外卖加this.iswork = false;或者在实例好newHuman之后添加h.iswork = false。最后还是输出underfined。</p>
<p>然后继续看下面一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">worker</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.isWorking = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">this</span>.startWork = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.isWorking) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">this</span>.isWorking = <span class="literal">true</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tom = <span class="keyword">new</span> worker(<span class="string">"tom"</span>, <span class="number">40</span>);</span><br><span class="line"><span class="keyword">var</span> jim = <span class="keyword">new</span> worker(<span class="string">"jim"</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(tom.startWork == jim.startWork);</span><br><span class="line"><span class="comment">//最终输出的结果是：false</span></span><br></pre></td></tr></table></figure></p>
<p>对于我来说，上面这段代码消除了我原来在上面的代码的疑问，因为这里没有return，可是依然可以访问到实例后的成员属性，不过我在上面一段代码中其实是用试过这样改的，但是输出的结果一样。<br>但是我们从最终的输出结果来看，可以知道最终实例好的tom和jim其实值得内存是不一样的，这样意味着当我们需要创建很多实例的时候，内存的开销会非常大。于是我们看下一段代码进行改善：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">worker</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.isWorking = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">worker.prototype.startWork = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>.isWorking) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">this</span>.isWorking = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tom = <span class="keyword">new</span> worker(<span class="string">"tom"</span>, <span class="number">40</span>);</span><br><span class="line"><span class="keyword">var</span> jim = <span class="keyword">new</span> worker(<span class="string">"jim"</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> html = <span class="string">"tom和jim两个实例的startWork方法是否共用内存 : "</span> </span><br><span class="line">				+ (tom.startWork == jim.startWork).toString();</span><br><span class="line"><span class="built_in">document</span>.write(html);</span><br></pre></td></tr></table></figure></p>
<p>run上面的代码的时候输出的结果是tom和jim两个实例的startWork方法是否共用内存 : true。这下两个不同实例的startwork是指向相同的地址了，说明了不同的实例共用了该方法。</p>
<p>在设计javascript的时候遵循下面两条规则<br>1，因为实例不同而不同的内容，用this关键字声明<br>2，无论实例怎样内容完全相同的成员，定义在prototype上</p>
<p>而上面第二条所说的prototype其实就是原型，<strong>任何类型都会有属于自己的原型，并且原型上定义的成员，可以在每个实例中引用，并且是共用的</strong>，其实我不太明白这句话，不过初步理解肯定是定义的成员能共用同一块内存。</p>
<p>然后对比相面的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.startWith = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> str.indexOf(str) == <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"abc"</span>;</span><br><span class="line"><span class="built_in">document</span>.write(str.startWith(<span class="string">"ab"</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.prototype.endWith = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> str.indexOf(str) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = <span class="string">"test"</span>;</span><br><span class="line"><span class="built_in">document</span>.write(test.endWith(<span class="string">"a"</span>));</span><br></pre></td></tr></table></figure></p>
<p>这里可以看出一些规律，首先是上面哪一段代码里面是worker.prototype.startWork通过使用new worker来创建一个实例，但是这里是String.prototype.endWith来创建的方法，自然就是使用String类来创建变量。当然把String改成Boolean的话，声明变量就只能用true和false了。</p>
<p>看了一天，总算是明白了这里的意思：就是javascript的成员定义是写在定义域外面的，这和我们java的不一样，因此尽管已经是定义好的String或者Data类型，我们依然可以使用javascript这种特殊的语法结构进行扩展和修改。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1，其实，写了上述那么多例子，应该能看出点什么？作为一名写java写了两年的小程序员，在学习javascript过程中我一直在想象这两门语言的不同之处和相同之处，其实这里我们可以把父function看作java的类，也就是javascript所说的对象，然后父function所嵌入的function就是我们一直都知道的方法这个概念了，只不过奇特的是javascript在设计的时候会遵循一些规则，其中一条就是定义内容相同的成员，要定义在外部的prototype上，所以才会看到如上面的代码这样把方法写出来。<br>语法结构可以概括为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(父<span class="function"><span class="keyword">function</span>).<span class="title">prototype</span>.(<span class="params">成员方法名字</span>) = <span class="title">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//此处编写代码逻辑</span></span><br><span class="line">	<span class="comment">//在此方法内部使用成员变量需要加关键字this</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>2，另外一种定义父类的方法就是直接通过var关键字定义一个实例对象，通过键值对来存储，存储类型可以是：String，boolean，Integer，function等基本类型。<br>语法结构：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里需要注意一些语法问题，例如一些标点符号的使用</span></span><br><span class="line"><span class="keyword">var</span> objName = &#123;</span><br><span class="line">	key1 : <span class="string">"String"</span>,</span><br><span class="line">	key2 : <span class="number">3</span>,</span><br><span class="line">	key3 : <span class="literal">false</span>,</span><br><span class="line">	key4 : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>关于javascript的继承我们同样有两种方法来实现，首先是对原始对象使用<strong>$.entend</strong>关键字，继承之后可以拥有父类对象也可以重写父类型还可以自定义自己的成员。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个工人</span></span><br><span class="line">    <span class="keyword">var</span> worker = &#123;</span><br><span class="line">        name : <span class="string">""</span>,</span><br><span class="line">        age : <span class="number">0</span>,</span><br><span class="line">        isWorking : <span class="literal">false</span>,</span><br><span class="line">        startWork : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//some code here</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//定义一个工头，工头本身也是工人，但他有一个额外的属性，用于记录他所管理的员工列表，并且可以指挥一名工人开工</span></span><br><span class="line">    <span class="keyword">var</span> leader = $.extend(worker,&#123;</span><br><span class="line">        workers : [],</span><br><span class="line">        callStart : <span class="function"><span class="keyword">function</span>(<span class="params">worker</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//指挥一名工人开工</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//此时的leader除了拥有name，age，isWorking，startWork这四项属性之外，还拥有workers和callStart成员。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="父类的构造函数调用"><a href="#父类的构造函数调用" class="headerlink" title="父类的构造函数调用"></a>父类的构造函数调用</h2><p>对于function创建的类型，其自身是无法进行$.extend的，这时候我就可以想到java的父类调用了，java是可以使用super关键字对于已经继承了父类进行构造函数的调用。而这里是使用：[function的名字].apply(this, arguments);其中这里的arguments是参数列表。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseClass</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.a = a;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aClass</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	baseClass.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> aClass(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">document</span>.write(test.a);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(test.b);</span><br><span class="line"><span class="comment">//输出1 2</span></span><br></pre></td></tr></table></figure></p>
<p>对于刚学javascript的我需要在开始的时候仔细整理一下我的思路：<br>首先是apply关键字，我可以把它看作是java中的super关键字，就好像是指针指向对应创建的构造函数的内存空间，相当于反射。<br>而通过baseClass.apply(this,arguments);相当于使用当前的实例和当前函数执行一次baseClass方法,这样看起来好像没有什么作用，仅仅是可以节省一些代码来调用另外一个函数。</p>
<p>直接继承：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">worker</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">worker.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">document</span>.write(<span class="string">"hello ! &lt;br/&gt;"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leader</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	worker.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line">leader.prototype = worker.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> l = <span class="keyword">new</span> leader(<span class="string">"jim"</span>);</span><br><span class="line">l.sayHello();</span><br><span class="line"><span class="comment">//输出 hello！</span></span><br></pre></td></tr></table></figure></p>
<p>而直接继承成员会有缺陷：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">worker</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.isWorking = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">worker.prototype.startWork = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>.isWorking) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">this</span>.isWorking = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leader</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">	worker.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">this</span>.workers = [];</span><br><span class="line">&#125;</span><br><span class="line">leader.prototype = worker.prototype;</span><br><span class="line">leader.prototype.startWork = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//重写工人的开始工作方法，工头开工时，下属工人也要开工</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.isWorking) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> workerLength = <span class="keyword">this</span>.workers.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; workerLength; i++)&#123;</span><br><span class="line">    	<span class="keyword">this</span>.workers[i].startWork();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tom = <span class="keyword">new</span> leader(<span class="string">"tom"</span>,<span class="number">40</span>);</span><br><span class="line"><span class="keyword">var</span> jim = <span class="keyword">new</span> worker(<span class="string">"jim"</span>,<span class="number">20</span>);</span><br><span class="line">tom.workers.push(jim);</span><br><span class="line">tom.startWork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> html = <span class="string">"tom和jim两个实例的startWork方法是否共用内存 : "</span> + (tom.startWork == jim.startWork).toString();</span><br><span class="line"><span class="built_in">document</span>.write(html);</span><br></pre></td></tr></table></figure></p>
<p>上面的代码其实我没有读太明白，我知道因为在leader中他新创建了一个空的workers集合，而他的父类没有workers集合，但是在startWork里面调用的isWorking里面的，因此会由于在worker里面找不到workers集合，会出现异常。呃，我只能这样理解不知道正不正确。</p>
<p>另外还有一点就是倒数第四句的<strong>tom.workers.push(jim);</strong>是什么意思，删掉之后也对程序没什么影响，我觉得学到后面才可以知道它的作用。另外经过证实我的理解可能是正确的是，我通过在worker中加入一句<strong>this.workers = [];</strong>然后程序就跑起来了，输出的结果是tom和jim两个实例的startWork方法是否共用内存 : true。</p>
<p>我们再看下一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">worker</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.isWorking = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">worker.prototype.startWork = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>.isWorking) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">this</span>.isWorking = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leader</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">	worker.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">this</span>.workers = [];</span><br><span class="line">&#125;</span><br><span class="line">leader.prototype = <span class="keyword">new</span> worker();	<span class="comment">//重点</span></span><br><span class="line">leader.prototype.startWork = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//重写工人的开始工作方法，工头开工时，下属工人也要开工</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.isWorking) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> workerLength = <span class="keyword">this</span>.workers.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; workerLength; i++)&#123;</span><br><span class="line">    	<span class="keyword">this</span>.workers[i].startWork();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tom = <span class="keyword">new</span> leader(<span class="string">"tom"</span>,<span class="number">40</span>);</span><br><span class="line"><span class="keyword">var</span> jim = <span class="keyword">new</span> worker(<span class="string">"jim"</span>,<span class="number">20</span>);</span><br><span class="line">tom.workers.push(jim);</span><br><span class="line">tom.startWork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> html = <span class="string">"tom和jim两个实例的startWork方法是否共用内存 : "</span> + (tom.startWork == jim.startWork).toString();</span><br><span class="line"><span class="built_in">document</span>.write(html);</span><br><span class="line"><span class="comment">//输出的结果是：tom和jim两个实例的startWork方法是否共用内存 : false</span></span><br></pre></td></tr></table></figure></p>
<p>对比上面哪一段代码，这段代码增加了一段<strong>leader.prototype = new worker();</strong>，我们先看一下其他代码和上面的一样，另外worker方法里面也没有对应的workers集合，再运行一下代码，可以运行，没有抛出异常。<br>另外看一下输出的结果也不是true，通过现象看本质，可以看到现在leader和worker对应的内存空间肯定不一样了。我们来听一下比较官方的解释：通过leader.prototype = new worker();这段代码相当于创建了一个worker实例，并将这个实例中的各个成员复制给leader的原型，这样一来对子类的修改仅仅是影响worker的实例，而不会影响worker的原型。</p>
<p>学完这些之后要好好分析一下上面的代码才可以，根据代码解释的顺序来分析；<br>首先是创建了一个worker父类方法，然后使用方法的规则创建一个内存共享的startWork成员方法，将新建的leader使用apply关键字继承worker，并且新创建一个workers集合。<br>然后使用leader.prototype = new worker();这段代码继承父类的副本实例对象，接下来就可以重写父类的startWork成员方法了，不过这里面写的一大段东西我都不太明白是什么意思<br>接下来就是实例化父类和子类了，事实证明，接下来的代码里面，tom.startWork();这段代码是没有用处的，感觉仅仅是个开关功能，不知道有没有执行到for循环，接着再下下面的代码就没什么可以分析的了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/20/nodeJS入门基础/" itemprop="url">
                  nodeJS入门基础
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-07-20T11:27:57+08:00" content="2016-07-20">
              2016-07-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/20/nodeJS入门基础/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/07/20/nodeJS入门基础/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是NodeJS？"><a href="#什么是NodeJS？" class="headerlink" title="什么是NodeJS？"></a>什么是NodeJS？</h2><p>Node是一个服务器端的javascript解释器,它将改变服务器应该如何工作的概念。它的目标是帮助程序员构建高度可伸缩的应用程序，编写能够处理数万条同时连接到一个（只有一个）物理机的连接代码。<br>Node解决并发连接最大数量的方法是：每个连接发射一个在 Node 引擎的进程中运行的事件，而不是为每个连接生成一个新的 OS 线程（并为其分配一些配套内存）。Node 声称它绝不会死锁，因为它根本不允许使用锁，它不会直接阻塞 I/O 调用。Node 还宣称，运行它的服务器能支持数万个并发连接。</p>
<p>在学习react-native的时候发现有些后备知识不太健全，于是按照学习入门的要求就来看了一下nodejs的入门，但是这里我就不详细说学习步骤了，网上有一大堆步骤，我只说我遇到的一些问题和解决办法</p>
<h2 id="有关函数传递"><a href="#有关函数传递" class="headerlink" title="有关函数传递"></a>有关函数传递</h2><hr>
<p>写好一个以http服务器的server之后，我们如果想要模块化这个功能，在其他js文件里面调用这个server模块的时候就要在对应的server结尾处添加一段代码；</p>
<h2 id="server-js"><a href="#server-js" class="headerlink" title="server.js"></a>server.js</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var http = require("http");</span><br><span class="line"></span><br><span class="line">function start() &#123;</span><br><span class="line">  function onRequest(request, response) &#123;</span><br><span class="line">    console.log("Request received.");</span><br><span class="line">    response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;);</span><br><span class="line">    response.write("Hello World");</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  http.createServer(onRequest).listen(8888);</span><br><span class="line">  console.log("Server has started.");</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br></pre></td></tr></table></figure>
<h2 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var server = require("./server");</span><br><span class="line"></span><br><span class="line">server.start();</span><br></pre></td></tr></table></figure>
<p>这里只需要关注一下server.js的function的名字和对应导出去的那个start方法。<br>我在测试的时候相应的改动了三处：</p>
<blockquote>
<p>修改function的start，改为starter，报错为在server.js中的ReferenceError: start is not defined，意思是引用错误，start方法未被定义。<br>修改了一下function的start为starter还有末尾的exports.start = start改为exports.start = starter,此时服务器正常启动<br>根据程序员的正常嗅觉可以知道这时候要改动的就是exports.starter = start为exports.starter = start，另外修改了index.js的server.start为server.starter,很明显这时候正常运行<br>通过自己的测试可以知道这里的引用对象是exports函数通过声明一个新的start变量来存储在server.js中的start方法，因此最后一句是赋值语句，呃，这个好像不说大家也知道。<br>最后在index中通过requie将函数传递进来，通过“函数.方法”方法来调用传递过来的方法。</p>
</blockquote>
<h2 id="入门第二天"><a href="#入门第二天" class="headerlink" title="入门第二天"></a>入门第二天</h2><hr>
<p>我开始学到函数式编程，也就是我们把一个函数当作是参数来传递，在我写好的index文件中，将router对象传递技进去，服务器随后可以调用这个对象的route函数。也就是不把函数看作是一个名词，而是一个动词。</p>
<p>这次新创建了一个requestHandlers的模块，并且对于每一个请求处理程序，添加一个占位用函数，并随后将函数导出：</p>
<h2 id="requestHandlers-js"><a href="#requestHandlers-js" class="headerlink" title="requestHandlers.js"></a>requestHandlers.js</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function start() &#123;</span><br><span class="line">  console.log("Request handler 'start' was called.");</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function upload() &#123;</span><br><span class="line">  console.log("Request handler 'upload' was called.");</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br><span class="line">exports.upload = upload;</span><br></pre></td></tr></table></figure>
<h2 id="index-js-1"><a href="#index-js-1" class="headerlink" title="index.js"></a>index.js</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var server = require("./server");</span><br><span class="line">var router = require("./router");</span><br><span class="line">var requestHandlers = require("./requestHandlers");</span><br><span class="line"></span><br><span class="line">var handle = &#123;&#125;</span><br><span class="line">handle["/"] = requestHandlers.start;</span><br><span class="line">handle["/start"] = requestHandlers.start;</span><br><span class="line">handle["/upload"] = requestHandlers.upload;</span><br><span class="line"></span><br><span class="line">server.start(router.route, handle);</span><br></pre></td></tr></table></figure>
<h2 id="server-js-1"><a href="#server-js-1" class="headerlink" title="server.js"></a>server.js</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var http = require("http");</span><br><span class="line">var url = require("url");</span><br><span class="line"></span><br><span class="line">function start(route, handle) &#123;</span><br><span class="line">  function onRequest(request, response) &#123;</span><br><span class="line">    var pathname = url.parse(request.url).pathname;</span><br><span class="line">    console.log("Request for " + pathname + " received.");</span><br><span class="line"></span><br><span class="line">    route(handle, pathname);</span><br><span class="line"></span><br><span class="line">    response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;);</span><br><span class="line">    response.write("Hello World");</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  http.createServer(onRequest).listen(8888);</span><br><span class="line">  console.log("Server has started.");</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br></pre></td></tr></table></figure>
<h2 id="route-js"><a href="#route-js" class="headerlink" title="route.js"></a>route.js</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function route(handle, pathname) &#123;</span><br><span class="line">  console.log("About to route a request for " + pathname);</span><br><span class="line">  if (typeof handle[pathname] === 'function') &#123;</span><br><span class="line">    handle[pathname]();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log("No request handler found for " + pathname);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.route = route;</span><br></pre></td></tr></table></figure>
<p>从上到下观察改动的对象和函数可以知道一些东西，例如，首先为了能低耦合的方式将对象注入到route函数中，我们需要将requestHandlers.js写好的两个函数导出去，外部调用。<br>然后是看到index.js，注意这里的handle是一个包装了请求处理程序的集合，我直接照搬书里的话，正如所见，将不同的url映射到相同的请求处理程序上是是很容易的：只要在对象中添加一个键为”/“的属性，对应requestHandlers.start即可，这样我们就可以干净简洁地配置/start和/的请求都交由start这一处理程序处理。<br>接着就是server.js，在start里面添加了一个新的参数，然后通过参数传入到route回调函数里面去，因此我们也要修改一下route函数。<br>route函数的代码我们可以这样来阅读，首先判断给定的路径对应的请求程序也就是这里的方法function是否存在，如果存在的话就直接调用相应的函数。这样一来就很好解释简洁流畅的形如handle<a href="">pathname</a>;的表达式了<br>也就是说，如果传进去的pathname是刚刚在index集合中某一个，就会触发对应的函数，我们在index可以把这些集合和我们安卓的map相关起来，就是通过键值对来解释对应的pathname和函数程序。</p>
<h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><hr>
<p>首先更改掉start请求处理程序，我们让它等待10秒之后再返回hello Start，由于javascript没有sleep的操作，所以只能自己创建一个方法。</p>
<h2 id="修改requestHandlers-js修改如下"><a href="#修改requestHandlers-js修改如下" class="headerlink" title="修改requestHandlers.js修改如下"></a>修改requestHandlers.js修改如下</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function start() &#123;</span><br><span class="line">  console.log("Request handler 'start' was called.");</span><br><span class="line"></span><br><span class="line">  function sleep(milliSeconds) &#123;</span><br><span class="line">    var startTime = new Date().getTime();</span><br><span class="line">    while (new Date().getTime() <span class="tag">&lt; <span class="attr">startTime</span> + <span class="attr">milliSeconds</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="attr">sleep</span>(<span class="attr">10000</span>);</span><br><span class="line">  <span class="attr">return</span> "<span class="attr">Hello</span> <span class="attr">Start</span>";</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">function</span> <span class="attr">upload</span>() &#123;</span><br><span class="line">  <span class="attr">console.log</span>("<span class="attr">Request</span> <span class="attr">handler</span> '<span class="attr">upload</span>' <span class="attr">was</span> <span class="attr">called.</span>");</span><br><span class="line">  <span class="attr">return</span> "<span class="attr">Hello</span> <span class="attr">Upload</span>";</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">exports.start</span> = <span class="attr">start</span>;</span><br><span class="line"><span class="attr">exports.upload</span> = <span class="attr">upload</span>;</span></span><br></pre></td></tr></table></figure>
<p>当我们单独打开<a href="http://localhost:8888/start和http://localhost:8888/upload的时候，按照程序的逻辑，start函数会先等待10秒，然后再返回hello" target="_blank" rel="external">http://localhost:8888/start和http://localhost:8888/upload的时候，按照程序的逻辑，start函数会先等待10秒，然后再返回hello</a> start。而upload则会立即返回。<br>但是当我们重启浏览器，然后开启两个窗口，分别输入上面的两个地址但是不要打开，现在“/start”按下回车，快速切换到第二个窗口“/upload”也按下回车，这里发生了点事情，/start URl花了10秒，/upload也花了10秒，这就非常奇怪了，到底为什么？<br>原因是start()包含了阻塞操作，node实行的是并行执行，也就是node在不增加额外线程的情况下，依然可以对人物进行并行处理，node是单线程的，通过<a href="http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/" target="_blank" rel="external">事件轮询</a>来实现并行操作，一个队列如果阻塞了之后就会导致线程被占用而后面需要处理的程序被阻塞。</p>
<p>为了尽可能的避免阻塞操作，我们需要使用非阻塞操作，将函数作为参数传递给其他需要花时间做处理的函数，在完成之后使用回调传回到主线程上。ok，开始初步更改：<br>还是更改requestHandlers.js<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var exec = require("child_process").exec;</span><br><span class="line"></span><br><span class="line">function start() &#123;</span><br><span class="line">  console.log("Request handler 'start' was called.");</span><br><span class="line">  var content = "empty";</span><br><span class="line"></span><br><span class="line">  exec("ls -lah", function (error, stdout, stderr) &#123;</span><br><span class="line">    content = stdout;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function upload() &#123;</span><br><span class="line">  console.log("Request handler 'upload' was called.");</span><br><span class="line">  return "Hello Upload";</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br><span class="line">exports.upload = upload;</span><br></pre></td></tr></table></figure></p>
<p>上述代码使用了一个叫做child_process的nodejs模块，使用它是为了实现一个非常简单的非阻塞操作：exec().它能做什么，它能使用node的一天shell指令来遍历当前目录下的所有文件(“ls -lah”)，当/startURl的时候将文件信息输出到浏览器中。<br>上述代码访问呢“<a href="http://localhost:8888/start”" target="_blank" rel="external">http://localhost:8888/start”</a> 的运行结果是只出现了一个empty，这时候很明显就是想到了新添加的exec()函数发挥作用了，有了它，我们可以在执行非常耗时的操作的时候无需等待，如果换成”/find”会更加明显，因为find/，一般情况下执行时间会非常久，但是这并不是我们想要的效果。<br>我们先来分析一下exec()函数的，在例子中，回调函数function (error, stdout, stderr)是作为第二个参数传递给exec()的匿名函数。当代码执行到exec()之后，node就立即执行了return content；而这个时候，content依旧是“empty”，因为传递给exec()的回调函数还没有执行到——因为exec()的操作是异步的。<br>所以尽管只要耗时稍微比较长的话，都会交给node在后天继续执行下去，但是函数却调到下一条代码了，那么要怎么才能将检索好的目录呈现给用户呢？</p>
<h3 id="用非阻塞的方式进行请求响应"><a href="#用非阻塞的方式进行请求响应" class="headerlink" title="用非阻塞的方式进行请求响应"></a>用非阻塞的方式进行请求响应</h3><p>鉴于上面那种只实现了将耗时的操作交给回调函数处理，但是处理好的结果却没有很好的呈现出来，因此我们需要其他的计划和解决方法。刚好，nodeJS就有一种实现方案：函数传递。<br>这种新的方式是通过和旧的方式将内容传递给服务器想比，我们采用将服务器传递给内容的方式。从实践的角度来看，就是将response对象（从回调函数onRequest（）获取）通过请求路由传递给处理程序。随后。处理程序就可以采用该对象上的函数来对请求做出响应。</p>
<h3 id="首先是server-js函数："><a href="#首先是server-js函数：" class="headerlink" title="首先是server.js函数："></a>首先是server.js函数：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var http = require("http");</span><br><span class="line">var url  = require("url");</span><br><span class="line"></span><br><span class="line">function start(route, handle)&#123;</span><br><span class="line">	function onRequest(request, response)&#123;</span><br><span class="line">		var pathname = url.parse(request.url).pathname;</span><br><span class="line">		console.log("Request for " + pathname + " received.");</span><br><span class="line">		</span><br><span class="line">		route(handle, pathname, response);</span><br><span class="line">	&#125;</span><br><span class="line">	http.createServer(onRequest).listen(8888);</span><br><span class="line">	console.log("Server has started.");</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br></pre></td></tr></table></figure>
<p>route.js<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function route(handle, pathname, response)&#123;</span><br><span class="line">	console.log("About to route a request for " + pathname);</span><br><span class="line">	if(typeof handle[pathname] == 'function')&#123;</span><br><span class="line">		handle[pathname](response);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		console.log("No request handler found for " + pathname);</span><br><span class="line">		response.writeHead(404,&#123;"Content-type":"text/plain"&#125;);</span><br><span class="line">		response.write("404 Not found");</span><br><span class="line">		response.end();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.route = route;</span><br></pre></td></tr></table></figure></p>
<p>最后是requestHandler.js函数<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var exec = require("child_process").exec;</span><br><span class="line"></span><br><span class="line">function start(response) &#123;</span><br><span class="line">  console.log("Request handler 'start' was called.");</span><br><span class="line"></span><br><span class="line">  exec("ls -lah", function (error, stdout, stderr) &#123;</span><br><span class="line">    response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;);</span><br><span class="line">    response.write(stdout);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function upload(response) &#123;</span><br><span class="line">  console.log("Request handler 'upload' was called.");</span><br><span class="line">  response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;);</span><br><span class="line">  response.write("Hello Upload");</span><br><span class="line">  response.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br><span class="line">exports.upload = upload;</span><br></pre></td></tr></table></figure></p>
<p>参考文章：[Node.js 究竟是什么？]{<a href="http://www.ibm.com/developerworks/cn/opensource/os-nodejs/index.html?ca=drs#icomments}" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/opensource/os-nodejs/index.html?ca=drs#icomments}</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/default_avatar.jpg"
               alt="漏雨" />
          <p class="site-author-name" itemprop="name">漏雨</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">44</span>
              <span class="site-state-item-name">Artikel</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">Kategorien</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">Tags</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">漏雨</span>
</div>

<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>





      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=0.5.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'greatzuesgithubio';
      var disqus_identifier = 'page/2/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  



  
  
  

  


</body>
</html>
