<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="zues blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="zues blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="zues blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zues blog">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?b706031fedc2f13c7dc61b81d4a77d64";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


  <title> zues blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">zues blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/31/ES6入门/" itemprop="url">
                  ES6入门
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-07-31T16:40:00+08:00" content="2016-07-31">
              2016-07-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/31/ES6入门/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/07/31/ES6入门/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>我是在学习react-native官网的时候说开发react-native需要用到ES6的时候才开始学的，一切都还是刚刚开始，我标记一下我是在<a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">阮一峰老师的书</a>中学习的，非常棒的一本书，习惯看书学习的同学可以自己去买一本来看，链接之后就有购买途径了。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr>
<p>ES6是ECMAScript 6.0的简称，也是javascript的下一代标准，尽管这套标准目前还没有在所有的浏览器上完整实现，所以目前而言web开发中还很少使用，但是React Native内置了对ES2015(也就是ES6)标准的支持，你可以放心使用而无需担心兼容性问题。</p>
<h2 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h2><hr>
<p>先看一段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  let a = 10;</span><br><span class="line">  var b = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a // ReferenceError: a is not defined.</span><br><span class="line">b // 1</span><br></pre></td></tr></table></figure></p>
<p>我们能看到注释，在代码快使用var和let声明两个变量，在代码块外调用，let声明的变量报错而var声明的会返回正确的值。这也能看出，let声明的变量只在它所在的代码块有效。</p>
<p>因此我们可以使用let命令写for循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; arr.length; i++) &#123;&#125;</span><br><span class="line"></span><br><span class="line">console.log(i);</span><br><span class="line">//ReferenceError: i is not defined</span><br></pre></td></tr></table></figure></p>
<p>可以看到在循环体外log是会报错的。再看下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 10</span><br></pre></td></tr></table></figure></p>
<p>for循环的i是var声明的，在全局范围内有效，每一次循环都会覆盖旧的值，因此最后输出的是最后一轮的i值。而使用let的话，最后输出的是6，那为什么会是6呢！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 6</span><br></pre></td></tr></table></figure></p>
<p>因为在每一次for循环中，每一次的i都只会在该次循环中存在并且有效，而循环结束到下一次循环开始，又会进行let i = i + 1的操作，从而跳出该次循环，但是同时又重新为i赋了一个值。导致最后的数组a[]方法在每一次循环生成不同的function。</p>
<pre><code>不管是用let还是var声明，变量都要在声明后使用，否则就会报错。
</code></pre><h3 id="暂时性死区（temporal-dead-zone，简称TDZ）"><a href="#暂时性死区（temporal-dead-zone，简称TDZ）" class="headerlink" title="暂时性死区（temporal dead zone，简称TDZ）"></a>暂时性死区（temporal dead zone，简称TDZ）</h3><p>如果在局部代码块中使用<strong>let</strong>和<strong>const</strong>命令，这些区块就会形成封闭作用域，在变量声明之前使用这些变量就会报错，尽管可能在代码块外面已经用var声明过同名变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var tmp = 123;</span><br><span class="line"></span><br><span class="line">if (true) &#123;</span><br><span class="line">  tmp = &apos;abc&apos;; // ReferenceError</span><br><span class="line">  let tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  // TDZ开始</span><br><span class="line">  tmp = &apos;abc&apos;; // ReferenceError</span><br><span class="line">  console.log(tmp); // ReferenceError</span><br><span class="line"></span><br><span class="line">  let tmp; // TDZ结束</span><br><span class="line">  console.log(tmp); // undefined</span><br><span class="line"></span><br><span class="line">  tmp = 123;</span><br><span class="line">  console.log(tmp); // 123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有些死区比较难以被发现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function bar(x = y, y = 2) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); // 报错</span><br></pre></td></tr></table></figure></p>
<p>因为在参数里面声明的x直接就调用y，而y此时还没被声明。因此这时候调用bar()就会报错，其实我写这个例子主要是不明白为什么在调用bar的时候不用带参，我写java的时候如果函数有参的话调用的时候也要带参，不管，我先标记一下！！！<br>反正不管怎样就是要先声明在使用变量就对了。</p>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var tmp = new Date();</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  console.log(tmp);</span><br><span class="line">  if (false) &#123;</span><br><span class="line">    var tmp = &quot;hello world&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); // undefined</span><br></pre></td></tr></table></figure>
<p>上面代码执行之后会输出undefined，因为变量提升，导致内层tmp覆盖外层的tmp。但是这里我的重心是这段代码是不是写错了，if()的false参数怎样传进去，如果不传进去怎么执行里面的函数，好奇怪，又得标记一下了。</p>
<p>第二种场景，用来计数的循环变量泄露为全局变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;hello&apos;;</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">  console.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(i); // 5</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p>
<h3 id="ES6的块状作用域"><a href="#ES6的块状作用域" class="headerlink" title="ES6的块状作用域"></a>ES6的块状作用域</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码最后输出5，表示let声明的变量外层代码块不受内层代码块的影响，但是使用var定义变量n，也就是把两个let都变成var，最后输出10.上面同一段代码我尝试了四种情况</p>
<blockquote>
<p>用let声明第一个n，用let声明第二个n，输出的是：5<br>用let声明第一个n，用var声明第二个n，输出的是：无任何输出结果<br>用var声明第一个n，用var声明第二个n，输出的是：10<br>用var声明第一个n，用let声明第二个n，输出的是：5<br>可以看出不允许将let放在比var等级更高的代码层，不然会报错。<br>
至于ES允许的块级作用域任意嵌套，**{{{{{let insane = 'Hello World'}}}}};**，我觉得没什么用处，但是可以知道一些，这时候外层作用域无法读取内层作用域的变量。
不过也正是块级作用域的出现，就可以逐渐淘汰掉现在被广泛使用的匿名函数(IIFE)不再必要了
undefined

块级作用域与函数声明
在ES6中，允许在块级作用域中声明函数，而这在ES5之前是不被允许的，规定函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。
undefined

很重要的一点是，ES6规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。
undefined

上面代码中，会得到“i am inside!”，因为在if内声明的函数f会被提升到函数头部。
> * 允许在块级作用域内声明函数。
> * 函数声明类似于var，即会提升到全局作用域或函数作用域的头部
> * 同时，函数声明还会提升到所在的块级作用域的头部

注意：上面三条规则只对ES6的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。

前面的代码在老版本的chrome环境在运行时会报错的。
因为在老版的chrome环境下被编译的时候会被解释成。
undefined

因为考虑到环境导致的行为差异太大，应避免在块级作用域内声明函数。加入确实需要也应该写成函数表达式，而不是声明语句。
undefined

另外，还有一个需要注意的地方。ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。
undefined

</p>
<h2 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h2><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。哈哈，记忆的时候就可以将这个词和我们java的final一起记忆了。<br>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo;</span><br><span class="line"><span class="comment">// SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>上面的代码表示，对于const一旦表明变量，就必修立即初始化，不能留到以后赋值，不然就会报错。</p>
<blockquote>
<ul>
<li>const的作用域与let命令相同：只在声明所在的块级作用域内有效。</li>
<li>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</li>
<li>const声明的常量，也与let一样不可重复声明。</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">foo.prop</span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">foo = &#123;&#125;; <span class="comment">// TypeError: "foo" is read-only</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，常量foo存储的是一个地址，这个地址指向一个对象。不可变的这个地址，而最后一句代码foo = {}相当于把foo指向另一个地址，于是就会报错，但那时对象本身是可变的，所以可以为期添加新属性。<br>下面是另一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.push(<span class="string">'Hello'</span>); <span class="comment">// 可执行</span></span><br><span class="line">a.length = <span class="number">0</span>;    <span class="comment">// 可执行</span></span><br><span class="line">a = [<span class="string">'Dave'</span>];    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，常量a是一个数组，这个数组本身是可以写的，但是如果将另一个数组赋值给a，就会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></span><br><span class="line"><span class="comment">// 严格模式时，该行会报错</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中使用了一个<strong>Object.freeze</strong>方法，将常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式下还会报错。</p>
<p>除了将对象本身冻结，对象的属性也可以被冻结，虽然我不知福冻结的用法在什么情况下会被用到。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constantize = (obj) =&gt; &#123;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach( (key, value) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span> ) &#123;</span><br><span class="line">      constantize( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>扩展</strong>：ES5只有两种声明变量的方法：var命令和function，命令。ES6除了添加let和const命令之外，还有其他声明变量的方法：import和class命令，而这些也是我要写react-native需要用到的，因此ES6一共会有6中声明变量的方法。</p>
<h3 id="全局对象的属性"><a href="#全局对象的属性" class="headerlink" title="全局对象的属性"></a>全局对象的属性</h3><p>全局对象是最顶层的对象，在浏览器环境指的是window对象，在nodejs中指的是global对象。ES5之中，全局对象的属性和全局变量是等价的,就像下面的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">1</span>;</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，全局对象的属性赋值和全局变量的赋值，被看做事同一件事（对于Node来说，这一条只对REPL环境适用，模块环境之中，全局变量必须显式声明成global对象的属性。这句不太明白，还是先标记一下以后明白之后再改正！！）</p>
<p>到了ES6之后就开始改变了，为了保持兼容性，var命令和function命令声明发的全局变量，依旧是全局变量的属性，另外有let命令，const命令class命令声明的全局变量，不属于全局变量的属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在Node的REPL环境，可以写成global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成this.a</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，全局变量a由var命令声明，所以他是全局变量的属性；而全局变量b由let声明，所以它不是全局变量的属性，返回undefined(未定义)。</p>
<p>终于看完这一章了，好多知识点啊！！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/31/react-native学习笔记2/" itemprop="url">
                  react-native学习笔记2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-07-31T10:45:15+08:00" content="2016-07-31">
              2016-07-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/31/react-native学习笔记2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/07/31/react-native学习笔记2/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="编写Hello-World"><a href="#编写Hello-World" class="headerlink" title="编写Hello World"></a>编写Hello World</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; AppRegistry, Text &#125; from &apos;react-native&apos;</span><br><span class="line"></span><br><span class="line">class HelloWorldApp extends Component &#123;</span><br><span class="line">	render() &#123;</span><br><span class="line">		return (</span><br><span class="line">			&lt;Text&gt;Hello World!&lt;/Text&gt;</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//注意，这里用引号括起来的&apos;HelloWorldApp&apos;必须和你init创建的项目名一致</span><br><span class="line">AppRegistry.registerComponent(&apos;HelloWorldApp&apos;, () =&gt; HelloWorldApp);</span><br></pre></td></tr></table></figure>
<p>然后一个简单的HelloWorldApp就完成了，不过鉴于第一次接触，所以要一步一步来分析每一步的意义。</p>
<p>首先需要了解上面的代码是我曾经学过的语言javascript，但是很明显这和我想象中javascript不像好不好，不过这确实是“未来”的javascript，最新的javascript官方标准是ES2015（也叫做ES6）.没错，在完全进行开发之前我还需要了解一下ES6.</p>
<p>简单看了一些ES6之后就要开始真干了，</p>
<h2 id="官网文档"><a href="#官网文档" class="headerlink" title="官网文档"></a>官网文档</h2><hr>
<p>官网的文档都是英文的，部分看不太懂，因为中文网最近不知道为什么突然就跪了，然后就只能对着官网的代码自己敲然后自己去翻译文档。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Sample React Native App</span><br><span class="line"> * https://github.com/facebook/react-native</span><br><span class="line"> * @flow</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; AppRegistry,  Image, Text, View, StyleSheet &#125; from &apos;react-native&apos;;</span><br><span class="line"></span><br><span class="line">class AwesomeProject extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    let pic = &#123;</span><br><span class="line">      uri: &apos;https://upload.wikimedia.org/wikipedia/commons/d/de/Bananavarieties.jpg&apos;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;View style = &#123;styles.container&#125;&gt;</span><br><span class="line">        &lt;Text&gt;hello wrold!&lt;/Text&gt;</span><br><span class="line">        &lt;Image source = &#123;pic&#125; style = &#123;&#123;width:193, height: 110&#125;&#125; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Greeting text=&apos;jsakdhkjasdh&apos; /&gt;</span><br><span class="line">        &lt;Greeting text = &apos;mike&apos; /&gt;</span><br><span class="line">        &lt;Greeting text = &apos;zues&apos; /&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Greeting extends Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;showText: true&#125;;</span><br><span class="line"></span><br><span class="line">    setInterval(() =&gt; &#123;</span><br><span class="line">      this.setState(&#123;showText: !this.state.showText &#125;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render ()&#123;</span><br><span class="line">    let display = this.state.showText ? this.props.text : &apos;&apos;;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Text&gt;&#123;display&#125;&lt;/Text&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const styles = StyleSheet.create(&#123;</span><br><span class="line">  container: &#123;</span><br><span class="line">    alignItems:&apos;center&apos;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">AppRegistry.registerComponent(&apos;AwesomeProject&apos;, () =&gt; AwesomeProject);</span><br></pre></td></tr></table></figure></p>
<p>这是在前两节的基础上，copy的第三节文档的代码。我想分析一下整理一下思路。首先是写好的class Greeting组件，这里的语法都是ES6的新语法，还好我及时恶补了一些。</p>
<p>首先是constructor构造函数，传入属性props，第一段代码就继承了父类的属性<code>super(props);</code>,然后先设定初始状态的成员变量showText为true。然后使用一个定时器作为开关，设定在1000毫秒内执行第一个参数来改变this.state.showText的值<code>this.setState({showText: !this.state.showText });</code>，然后就在render函数那里创建一个变量display存储一个判断的方法：<code>this.state.showText ? this.props.text : &#39;&#39;;</code>，代码的意思是如果this.state.showText如果为true的时候就显示this.props.text属性，否则就显示空字符。然后返回由<text>包裹的文字。</text></p>
<p>在这中间我尝试过修改了this.state为this.st或者是修改showText为show。但是修改之后效果就没有了，所以我初步断定this.state和showText为父类的属性和变量，因此不可以被修改。不过应该也可以理解，那就是在这些步骤之前使用了super关键字。</p>
<h2 id="关于style"><a href="#关于style" class="headerlink" title="关于style"></a>关于style</h2><hr>
<p>学到style的时候有开始模仿代码了，这次是样式的编写。类似官网的文档，模仿了下面的一段代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; AppRegistry,  Image, Text, View, StyleSheet &#125; from &apos;react-native&apos;;</span><br><span class="line"></span><br><span class="line">class AwesomeProject extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    let pic = &#123;</span><br><span class="line">      uri: &apos;https://upload.wikimedia.org/wikipedia/commons/d/de/Bananavarieties.jpg&apos;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;View style = &#123;styles.container&#125;&gt;</span><br><span class="line">        &lt;Text&gt;hello wrold!&lt;/Text&gt;</span><br><span class="line">        &lt;Image source = &#123;pic&#125; style = &#123;&#123;width:193, height: 110&#125;&#125; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Greeting text=&apos;jsakdhkjasdh&apos; /&gt;</span><br><span class="line">        &lt;Greeting text = &apos;mike&apos; /&gt;</span><br><span class="line">        &lt;Greeting text = &apos;zues&apos; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;LotIOfStyles /&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Greeting extends Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;showText: true&#125;;</span><br><span class="line"></span><br><span class="line">    setInterval(() =&gt; &#123;</span><br><span class="line">      this.setState(&#123;showText: !this.state.showText &#125;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render ()&#123;</span><br><span class="line">    let display = this.state.showText ? this.props.text : &apos;haha&apos;;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Text&gt;&#123;display&#125;&lt;/Text&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LotIOfStyles extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;View&gt;</span><br><span class="line">        &lt;Text style = &#123;styles.red&#125;&gt;just red&lt;/Text&gt;</span><br><span class="line">        &lt;Text style = &#123;styles.bigblue&#125;&gt;just bigblue&lt;/Text&gt;</span><br><span class="line">        &lt;Text style = &#123;[styles.bigblue, styles.red]&#125;&gt;bigblue, then red&lt;/Text&gt;</span><br><span class="line">        &lt;Text style = &#123;[styles.red, styles.bigblue]&#125;&gt;red, then bigblue&lt;/Text&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const styles = StyleSheet.create(&#123;</span><br><span class="line">  container: &#123;</span><br><span class="line">    alignItems:&apos;center&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  red: &#123;</span><br><span class="line">    color: &apos;red&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  bigblue: &#123;</span><br><span class="line">    color: &apos;blue&apos;,</span><br><span class="line">    fontWeight: &apos;bold&apos;,</span><br><span class="line">    fontSize: 30,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">AppRegistry.registerComponent(&apos;AwesomeProject&apos;, () =&gt; AwesomeProject);</span><br></pre></td></tr></table></figure></p>
<p>其实就是自己加了一个LotIOfStyles的类，然后再里面编写一些样式，读懂代码是没问题的，就是有一些小错会犯，在这里我要记下来提醒一下自己。</p>
<blockquote>
<ul>
<li>首先是styles的red和bigblue的大括号后面忘记写”,”这个小符号了，然后就是除了数字，其他的颜色和加粗之类的东西需要用<code>&#39;&#39;</code>这个符号来标识，经常会写成<code>&quot;&quot;</code>这个符号。</li>
<li>然后就是在写好四个<text>之后忘记用一个父类<view>包裹起来，这个很关键，我觉得后续我还会继续犯这个错，因为我暂时还没有完全学会这个语言。</view></text></li>
</ul>
</blockquote>
<h2 id="Height-and-Width"><a href="#Height-and-Width" class="headerlink" title="Height and Width"></a>Height and Width</h2><hr>
<p>一个组件的高度和宽度决定了组件在屏幕的尺寸。<br>最简单设置组件的宽度和高度的方法就是直接用内联样式将宽度和高度加进去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class FixedDimensionsBasics extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;View&gt;</span><br><span class="line">        &lt;View style = &#123;&#123;width: 50, height: 50, backgroundColor:&apos;powderblue&apos;&#125;&#125; /&gt;</span><br><span class="line">        &lt;View style = &#123;&#123;width: 100, height: 100, backgroundColor:&apos;skyblue&apos;&#125;&#125; /&gt;</span><br><span class="line">        &lt;View style = &#123;&#123;width: 150, height: 200, backgroundColor:&apos;steelblue&apos;&#125;&#125; /&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AppRegistry.registerComponent(&apos;AwesomeProject&apos;, () =&gt; FlexDimensionsBasics);</span><br></pre></td></tr></table></figure></p>
<p>这样就可以构造出三个小正方形了。</p>
<h2 id="Flexbox布局"><a href="#Flexbox布局" class="headerlink" title="Flexbox布局"></a>Flexbox布局</h2><hr>
<p>在React Native中使用flexbox规则来指定组件子元素的布局，Flexbox可以在不同的屏幕上提供一致的布局结构。但是一般情况下，使用<code>flexDirection</code>,<code>alignItems</code>,<code>justifyContent</code>三个样式就可以满足大部分的布局需求咯。</p>
<blockquote>
<p>React Native中的Flexbox的工作原理和web上的CSS基本一致，当然也存在少许差异。首先是默认值不同：flexDirection的默认值是column而不是row，alignItems的默认值是stretch而不是flex-start，以及flex只能指定一个数字值。</p>
</blockquote>
<h3 id="Flex-Direction"><a href="#Flex-Direction" class="headerlink" title="Flex Direction"></a>Flex Direction</h3><p>在组件的style中指定flexDirection可以决定布局的主轴。子元素可以是沿<strong>水平轴（row）</strong>方向排列，也可以是沿<strong>竖直轴（column）</strong>方向排列，而默认是竖直轴方向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class FlexDirectionBasics extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      // 尝试把`flexDirection`改为`column`看看</span><br><span class="line">      &lt;View style=&#123;&#123;flex: 1, flexDirection: &apos;row&apos;&#125;&#125;&gt;</span><br><span class="line">        &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: &apos;powderblue&apos;&#125;&#125; /&gt;</span><br><span class="line">        &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: &apos;skyblue&apos;&#125;&#125; /&gt;</span><br><span class="line">        &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: &apos;steelblue&apos;&#125;&#125; /&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AppRegistry.registerComponent(&apos;AwesomeProject&apos;, () =&gt; FlexDirectionBasics);</span><br></pre></td></tr></table></figure></p>
<p>这时候我发现了一个东西，身为初学者的我总是希望发现一些可以利用的知识点，很明显这里最后一句代码交代了这个项目（app）的名字叫做AwesomeProject，而入口组件则是FlexDirectionBasics。这就非常清晰明了了，以前我总以为要名字对应，现在才发现参数的实在意义。</p>
<h3 id="Justify-Content"><a href="#Justify-Content" class="headerlink" title="Justify Content"></a>Justify Content</h3><p>在组件的style中指定<code>justifyContent</code>可以决定其子元素沿着主轴的排列方式。子元素是应该靠近主轴的起始段还是末尾段分布呢？亦或应该是均匀分布呢？对应的这些可选项有：<code>flex-start</code>,<code>center</code>,<code>flex-end</code>,<code>space-around</code>以及<code>space-between</code>。不过其实这些我都看过教学视频，只不过当时没记下来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class JustifyContentBasics extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      // 尝试把`justifyContent`改为`center`看看</span><br><span class="line">      // 尝试把`flexDirection`改为`row`看看</span><br><span class="line">      &lt;View style=&#123;&#123;</span><br><span class="line">        flex: 1,</span><br><span class="line">        flexDirection: &apos;column&apos;,</span><br><span class="line">        justifyContent: &apos;space-between&apos;,</span><br><span class="line">      &#125;&#125;&gt;</span><br><span class="line">        &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: &apos;powderblue&apos;&#125;&#125; /&gt;</span><br><span class="line">        &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: &apos;skyblue&apos;&#125;&#125; /&gt;</span><br><span class="line">        &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: &apos;steelblue&apos;&#125;&#125; /&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>修改之后会出现几种情况，在英文官网的文档内修改也可以直接看到实时的效果，我实在本地编辑器修改测试的。</p>
<blockquote>
<p>一开始出现三个小正方形块上中下分别有一小块图像<br>修改justifyContent为center之后就变成三块合并在最左边中间<br>保留第二步不动，修改flexDirection之后就变成三块合并贴在最顶端的中间。</p>
</blockquote>
<p>因此大概可以猜到这些样式的用法了，我觉得以后经常使用会非常熟练，所以现在暂时还是测试一下不认真记录了。</p>
<h3 id="Align-Items"><a href="#Align-Items" class="headerlink" title="Align Items"></a>Align Items</h3><p>在组件的style中指定<code>alignItems</code>可以决定其子元素沿着次轴（与主轴垂直的轴，比如主轴此时为row，那么次轴就是column）的排列方式。子元素是应该靠近次轴的起始端还是末尾段分布呢？亦或应该均匀分布？对应的这些可选项有：<code>flex-start</code>、<code>center</code>、<code>flex-end</code>以及<code>stretch</code>。</p>
<p><strong>注意啦：</strong>要使stretch生效的话，子元素在次轴方向上不能有固定的尺寸。以下面的代码为例：只有将子元素样式中的<code>width：50</code>去掉之后，<code>alignItems:&#39;stretch&#39;</code>才会生效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class AlignItemsBasics extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      // 尝试把`alignItems`改为`flex-start`看看</span><br><span class="line">      // 尝试把`justifyContent`改为`flex-end`看看</span><br><span class="line">      // 尝试把`flexDirection`改为`row`看看</span><br><span class="line">      &lt;View style=&#123;&#123;</span><br><span class="line">        flex: 1,</span><br><span class="line">        flexDirection: &apos;column&apos;,</span><br><span class="line">        justifyContent: &apos;center&apos;,</span><br><span class="line">        alignItems: &apos;center&apos;,</span><br><span class="line">      &#125;&#125;&gt;</span><br><span class="line">        &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: &apos;powderblue&apos;&#125;&#125; /&gt;</span><br><span class="line">        &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: &apos;skyblue&apos;&#125;&#125; /&gt;</span><br><span class="line">        &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: &apos;steelblue&apos;&#125;&#125; /&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>三个尝试我觉得我以后能一下子看懂，主要是上面的注意，我觉得需要备注一下，因为这里的主轴方向是flexDirection是column（竖），所以次轴就是row（行），因此对应次轴的属性就是宽度不能有固定尺寸，相反，如果这时候主轴方向是row，那么子元素的宽度不能固定才能使stretch生效。</p>
<h2 id="预热"><a href="#预热" class="headerlink" title="预热"></a>预热</h2><hr>
<p>这个是看视频的时候抄的代码，觉得在刚学习的阶段应该会有用，所以先写下来记忆一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;script type =  /&gt;</span><br><span class="line">		&lt;script type =  /&gt;</span><br><span class="line">		&lt;script type =  /&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div id = &quot;example&quot;&gt;&lt;/div&gt;</span><br><span class="line">		&lt;script type = &quot;text/bable&quot;&gt;</span><br><span class="line">			var Parent = React.create(&#123;</span><br><span class="line">				click:function()&#123;</span><br><span class="line">					this.refd.child.getDOMNode().style.color=&quot;red&quot;;</span><br><span class="line">				&#125;,</span><br><span class="line">				render:function()&#123;</span><br><span class="line">					return (</span><br><span class="line">						&lt;div onClick=&#123;this.click&#125; &gt;Parents is:</span><br><span class="line">						&lt;Child name = &#123;this.props.name&#125; ref = &quot;child&quot; &gt;&lt;/child&gt;</span><br><span class="line">						&lt;/div&gt;</span><br><span class="line">					);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			</span><br><span class="line">			var Child = React.createClass(&#123;</span><br><span class="line">				render:function()&#123;</span><br><span class="line">					return &lt;span&gt; &#123;this.props.name&#125; &lt;span&gt;;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			</span><br><span class="line">			ReactDOM.render(&lt;Parent name = &quot;React语法基础&quot; /&gt; , document.getElementById(&apos;example&apos;));</span><br><span class="line">		&lt;/script&gt;		</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码不是react-native,而是react，不过还是可以先学习一下代码里面对于父类和子类之间的通信关系。<br>首先看child，代码很简单就是在渲染的时候直接返回一个span标签，里面是child的名字属性。<br>然后是父类，首先是创建一个click函数，暂时先不分析方法里面的细节，再看render函数，创建了一个div函数，并且在div的onClick方法中嗲用click函数。接着是直接使用child实例标签，这个实例里面含有一个那么的属性，关于属性的赋值是this.props.name，注意，这里认真一想还是很好理解的，那就是这个this是指向parent的，因此这里是先的到parent的name属性再赋值给child实例，这样一来就清晰很多了。<br>另外可以看到ref，我们可以把这个属性看成是标签作用，用来标记一个实例，我觉得可以把ref看成是id，回到click函数，函数里面的详细内容是this.refs.child.getDOMNode(),this.refs是找到有ref属性的实例，然后指向已经标记的实例，也就是child，刚刚命名的那个。去到对应的DOM节点，之后就可以对这个实例进行方法或者样式的变换了。这里是直接更改child的颜色，当然也可以写一个函数。</p>
<p>更加详细的属性列表<a href="http://reactnative.cn/docs/0.31/layout-props.html" target="_blank" rel="external">布局样式属性</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/29/正则表达式笔记/" itemprop="url">
                  正则表达式笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-07-29T17:46:27+08:00" content="2016-07-29">
              2016-07-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/29/正则表达式笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/07/29/正则表达式笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>正则表达式是为了记录文本规则的代码，在编写处理字符串或者网页的时候，经常会查找符合某些复杂规则的字符串而生。</p>
<p>首先举个例子，当我们需要查找某一个目录下的Word文档，我们会搜索<strong>*</strong>.doc，而这里的*就会变解释成任意的字符串，但是这里的<strong>*</strong>或者经常使用的<strong>?</strong>我们称做通配符。ok，开始学习</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><hr>
<p>假如我们需要在一边小说中查找一个单词“he”，一般情况下会怎么做呢？在我看来不管在什么情况下，我们都可以使用<strong>ctrl+f</strong>就会弹出查找的框。不过有时候比较糟糕的是很多单词都会有这两个字母，例如hello，head，heel等等，那么这时候就会有很多的he被找出来了，那当我们会使用正则表达式的话就可以使用<strong>\bhe\b</strong>.<br><strong>\b</strong>是正则表达式里面规定的一个特殊的代码，人称<strong>元字符</strong>，代表的那次的开头或者结尾，也就是单词的分界处。</p>
<p>假如这里he的后面不远处有一个Lucy，就可以使用<strong>\bhe\b.*\bLucy\b</strong>。<br>可以注意这里的<strong>.</strong>，它也是一个元字符，匹配除了换行符意外的任意字符。<strong>*</strong>同样是元字符，不过它代表的不是字符，也不是位置，而是指<strong>数量</strong>，它指定<strong>*</strong>号前边的内容可以连续重复使用任意次以使整个表达式得到匹配。<br>因此，<strong>.*</strong>就意味着<strong>任意数量的不包含换行的字符</strong>。那么现在<strong>\bhe\b.*\bLucy\b</strong>的意思就非常明显了：先是一个单词he，然后是任意字符串（不含换行）最后是lucy这个单词</p>
<p>这时候就可以联想肯定还有很多元字符，如果将其全部构造在一起那将是最强大的正则表达式。例如下面的例子：<br><strong>0\d\d-\d\d\d\d\d\d\d\d</strong>能匹配怎样的字符串呢：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字，我们的国家的电话号码就是这样的区号。<br>这里的<strong>\d</strong>是一个新的元字符，匹配一个<strong>数字</strong>（数字0-9）.但是这里的“-”号不是元字符，它只匹配一个符号，为了简便和避免出错，我们也可以用<strong>0\d{2}-\d{8}</strong>，{8}（或者{2}）表示连续重复。把<strong>{n}</strong>放在了\d前面，也就意味着前面的\d符号必须连续重复n次，相当于被copy了n次，于是就构造出了和上面区号一样的效果。</p>
<h3 id="小总结："><a href="#小总结：" class="headerlink" title="小总结："></a>小总结：</h3><blockquote>
<ul>
<li>元字符<strong>\b</strong>，代表着单词的口头或者结尾，记住是单词，而不是字符，它只匹配一个位置。</li>
<li>元字符<strong>.</strong>，匹配除了换行符以外的任意字符，记住只是单个字符。</li>
<li>元字符<strong>*</strong>，匹配的不是字符，也不是位置，肯定不能和别人抢饭碗对吧，所以它匹配的是数量，任意数量，它指定它前面的内容可以连续使用任意次从而使整个表达式得到匹配。</li>
<li>元字符<strong>\d</strong>，匹配的也是数量，但是这里它可以控制字符串多少，第一种比较傻，使用多少个“\d”就匹配多少个，而“\d{n}”，n是多少就能匹配多少次<strong>连续</strong>且重复。</li>
</ul>
</blockquote>
<h2 id="认识更多"><a href="#认识更多" class="headerlink" title="认识更多"></a>认识更多</h2><hr>
<p><strong>\ba\w*\b</strong>，首先看到\b就知道可以匹配以字母a开头的单词，然后是<strong>\w*</strong>，\w这个元字符的作用是可以匹配单个字母数字下划线或者汉字，和数量<strong>**相结合后就相当于任意数量的字母或者数字，最后\b是字母的结尾处。
</strong>\d+<strong>，可以匹配一个或更多连续的</strong>数字<strong>。这里的+是和<em>类似的元字符，不同的是不同的是</em>匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。
</strong>\b\w{6}\b**，可以匹配刚好6个字符的单词。</p>
<h3 id="常用元字符"><a href="#常用元字符" class="headerlink" title="常用元字符"></a>常用元字符</h3><table>
<thead>
<tr>
<th>代码</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td style="text-align:right">匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td>\w</td>
<td style="text-align:right">匹配字母或数字或下划线或汉字</td>
</tr>
<tr>
<td>\s</td>
<td style="text-align:right">匹配任意的空白符</td>
</tr>
<tr>
<td>\d</td>
<td style="text-align:right">匹配数字</td>
</tr>
<tr>
<td>\b</td>
<td style="text-align:right">匹配单词的开始或结束</td>
</tr>
<tr>
<td>^</td>
<td style="text-align:right">匹配字符串的开始</td>
</tr>
<tr>
<td>$</td>
<td style="text-align:right">匹配字符串的结束</td>
</tr>
</tbody>
</table>
<p>关于<strong>^</strong>和<strong>$</strong>令我有点蛋疼，因为\b也是可以匹配开头，不过这个是单词，但是^是匹配字符串，那也就是意味着^匹配的范围会更大，不过精确程度肯定是\b，另外这两个元字符还可以在允许处理多行的情况下变成匹配行的开始处和结尾处。<br>先来看一个表达式：<strong>^\d{5,12}$</strong>，这个表达式可以类似一个网站验证qq号，并且qq号必须为数字的重复次数不少于5次，不能多于12次。否则都匹配不成功。这里的<strong>{5，12}</strong>和前面\b的一样，意味着<strong>重复的次数不能少于5次，不能多于12次</strong>。</p>
<h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><hr>
<p>当我们需要查找的是正则里面的元符本身的话，正常情况下肯定找不到，这时候就要用<strong>\</strong>来消除这些字符的特殊意义，因此需要找.或者<em>的时候就要用.和\</em>。当然需要找<strong>\</strong>本身也需要使用\，因此在以后可以看到一些\\这样类型的，表示的是\。<br>例如：deerchao.net匹配deerchao.net，C:\Windows匹配C:\Windows。</p>
<h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><hr>
<p>前面已经知道了<em>表示前边的内容可以连续重复使用任意次以使整个表达式得到匹配，而+是和</em>类似但是匹配的次数重复1次或者更多，意味着一定会重复。另外{n}还有{5，12}我就不解释了，这个比较好记。</p>
<h3 id="常用的限定符"><a href="#常用的限定符" class="headerlink" title="常用的限定符"></a>常用的限定符</h3><table>
<thead>
<tr>
<th>代码/语法</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td style="text-align:right">重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td style="text-align:right">重复一次或更多次</td>
</tr>
<tr>
<td>?</td>
<td style="text-align:right">重复零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td style="text-align:right">重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td style="text-align:right">重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td style="text-align:right">重复n到m次</td>
</tr>
</tbody>
</table>
<p>例子：Windows\d+匹配Windows后面跟1个或更多数字，^\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)。</p>
<h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><hr>
<p>如果需要查找单个数字，字母都是比较简单的，但是如果需要找一些集合的时候，例如元音字母aeiou的时候怎么办，这时候只需要在方括号里面列出它们就可以了，就像这样[aeiou]就能匹配任何一个英文元音字母，[.?!]匹配标点里面的符号，从这里也可以看出在方括号里面是可以放元字符的，而无须转义。<br>当然也可以指定一个字符范围，[0-9]这个的含义就是和\d一样了：表示一个数字。同样这个例子[a-z0-9A-Z]，其实一开始我是没有看懂的，这里我们把里面的字符分开来看就可以看到a-z,0-9,A-Z这样就等同于\w了。</p>
<p>接下来是一个更加复杂的表达式：(?0\d{2}[) -]?\d{8}<br>这个表达式可以匹配集中格式的电话号码，像(010)88886666，或022-22334455，或02912345678等，对立面的字符进行分析，首先是转义的<strong>(</strong>，因为“（”和“）”都是元字符，它可能重复0次或者1次（？），然后是一个数字0，后面接着两个数字（\d{2}）,然后是方括号里面有-或者空格（要看到是有空格的）或者是“）”，也是出现一次或者零次，最后是8个重复的\d,也就是后面接着8个数字。</p>
<h2 id="分支条件"><a href="#分支条件" class="headerlink" title="分支条件"></a>分支条件</h2><hr>
<p>在上面的例子中是不是会出现一种情况，那就是假如是010)12345678或(022-87654321也是可以的，但是格式不是我们想要的，要解决这个问题需要使用到这节的标题。使用符号<strong>|</strong>把不同的规则分开，然后满足其中一种就可以完成匹配。<br>0\d{2}-\d{8}|0\d{3}-\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)<br>(?0\d{2})?[- ]?\d{8}|0\d{2}[- ]?\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。</p>
<p>\d{5}-\d{4}|\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用<strong>分枝条件时</strong>，要<strong>注意各个条件的顺序</strong>。如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。<br>对于上面一段话我有一点想法，那就是在分支匹配的时候要吧负责的匹配放在前面。不然的话复杂里面夹杂着简单的匹配的时候就会出现部分满足导致匹配不理想。还有就是<strong>|</strong>分支符号的左右都是完整的表达式，因此写这个的时候会显得和上面的方括号麻烦一些。</p>
<h2 id="分组-子表达式"><a href="#分组-子表达式" class="headerlink" title="分组/子表达式"></a>分组/子表达式</h2><hr>
<p>在前面我们知道了怎么重复单个字符，也就是前面那张表。但是如果需要重复多个字符的时候应该怎么办呢！这时候就要使用到标题，用小括号()来指定<strong>子表达式</strong>，然后就可以制定子表达式的重复次数。<br>(\d{1,3}.){3}\d{1,3}，这是一个ip地址的表达式，要理解这个表达式，我们一个一个来分析：既然是子表达式，所以肯定先分析括号里面的表达式，\d{1,3}匹配至少重复1到3位的数字，那么(\d{1,3}.){3}就是表示三位数字加一个英文句号（用了转义）重复三次，最后再加一个至少重复一次或者三次的数字（\d{1,3}）。<br>但是像上面的表达式避免不了匹配类似错误的ip256.300.888.999，因为正则没有提供关于数学的功能，因此需要冗长的表达式才可以正确描述：((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5])<br>可以发现最主要的分析对象是2[0-4]\d|25[0-5]|[01]?\d\d?，因为ip是1-255的，所以需要有几种情况，第一个分支2[0-4]，就是200-249，一看就看明白了，第二个分支25[0-5]，就是250-255，第三个分支有点难度[01]?\d\d?，意思是0或者1可能重复1次或者0次（不出现），后面接一个0-9的数字，再后面接着最多出现1次或者0次（不出现）的数字，也就是可以构造出两位数。</p>
<h2 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h2><hr>
<p>有时候需要找除了某一个字符以外的其他字符，于是这时候就要使用到反义。我个人觉得这样的情况很少见，除非一篇文章都差不多使用那么几种字符</p>
<h3 id="常用的反义字符"><a href="#常用的反义字符" class="headerlink" title="常用的反义字符"></a>常用的反义字符</h3><table>
<thead>
<tr>
<th>代码/语法</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\W</td>
<td style="text-align:right">匹配任意不是字母，数字，下划线，汉字的字符</td>
</tr>
<tr>
<td>\S</td>
<td style="text-align:right">匹配任意不是空白符的字符</td>
</tr>
<tr>
<td>\D</td>
<td style="text-align:right">匹配任意非数字的字符</td>
</tr>
<tr>
<td>\B</td>
<td style="text-align:right">匹配不是单词开头或者结束的位置</td>
</tr>
<tr>
<td>[^x]</td>
<td style="text-align:right">匹配除了x以外的任意字符</td>
</tr>
<tr>
<td>[^aeiou]</td>
<td style="text-align:right">匹配除了aeiou这几个字母以外的任意字符</td>
</tr>
</tbody>
</table>
<p>例子：\S+匹配不包含空白符的字符串，因为\S匹配不是空白符，而+要求至少要有重复，加在\S后面表示，不能有一个空白符或者多个空白符，理解下来就是没有任何空白符的<strong>字符串</strong>。<a[^>]+&gt;匹配用尖括号括起来的以a开头的字符串。<br><a[^>]+&gt;匹配用尖括号括起来的以a开头的字符串，这里需要注意尖括号不是元字符，所以就直接理解就可以了，而a[^&gt;]+表示a开头的字符串，并且a后面匹配除了&gt;符号的字符串，最后再加上最后那一个尖括号，于是就成为了用尖括号括起来的以a开头的字符串。</a[^></a[^></p>
<h2 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h2><hr>
<p>我的理解是通过后向对于已经被解释过的分组进行数字替代。用于重复搜索前面某个分组匹配的文本。例如， \1代表分组1匹配的文本。<br>例如：<strong>\b(\w+)\b\s+\1\b</strong>，可以用来匹配重复的单词，例如 go go，或者是kitty kitty。这个表达式先是一个单词，也就是单词开头和结尾处之间多余一个字母或数字的（\b(\w+)\b），这个单词在组号分配的时候会被捕获到编号为1的分组，然后是1个或几个空白符\s+，最后是分组1中捕获的内容。<br>除了可以自动陪匹配组号，还可以指定子表达式的组号，可以使用这样的语法：(?<word>\w+)(或者把尖括号换成’也是可以得:(?’Word’\w+))，这样就可以把\w+的组名指定为Word了，当需要反向指定这个分组的时候就可以使用\k<word>，所以上一个例子也可以写成这样：\b(?<word>\w)\b\s+\k<word>\b。)</word></word></word></word></p>
<p>为什么分组会从1开始呢！因为分组0对应的是整个正则表达式，而不是某一个分组，当然这里还有一个规则，就像上面说的除了那些没有命名被自动赋名的分组，还有已经被命名的分组，而组号分配是从左到右扫描两边，第一遍只给未命名组分配，第二次只给命名组分配，那么久可以很简单推测出所有命名组的组号都大于为命名组号。</p>
<h3 id="常用分组语法"><a href="#常用分组语法" class="headerlink" title="常用分组语法"></a>常用分组语法</h3><table>
<thead>
<tr>
<th>分类</th>
<th style="text-align:right">代码/语法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>捕获</td>
<td style="text-align:right">(exp)</td>
<td style="text-align:center">匹配exp,并捕获文本到自动命名的组里</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">(?<name>exp)</name></td>
<td style="text-align:center">匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">(?:exp)</td>
<td style="text-align:center">匹配exp,不捕获匹配的文本，也不给此分组分配组号</td>
</tr>
<tr>
<td>——</td>
<td style="text-align:right">——</td>
<td style="text-align:center">——–</td>
</tr>
<tr>
<td>零宽断言</td>
<td style="text-align:right">(?=exp)</td>
<td style="text-align:center">匹配exp前面的位置</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">(?&lt;=exp)</td>
<td style="text-align:center">匹配exp后面的位置</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">(?!exp)</td>
<td style="text-align:center">匹配后面跟的不是exp的位置</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">(?&lt;!exp)</td>
<td style="text-align:center">匹配前面不是exp的位置</td>
</tr>
<tr>
<td>—–</td>
<td style="text-align:right">—-</td>
<td style="text-align:center">——–</td>
</tr>
<tr>
<td>注释</td>
<td style="text-align:right">(?#comment)</td>
<td style="text-align:center">这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td>
</tr>
</tbody>
</table>
<p>例如可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权，其中exp是一个表达式，有效阻断组号分配，不过为什么要剥夺呢？我暂时还没有想到应用场景。</p>
<h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><hr>
<p>断言也就是可以预测位置，和\b,^,$一样具有指定位置的功能，并且这个位置具备一定的条件，在左边表示是前面，而在右边则是后面后面会一直持续提到这两个位置，因此被称作零宽断言。</p>
<p>(?=exp)也叫做<strong>零宽都正预测先行断言</strong>，它能断言<strong>表达式exp前面的位置</strong>。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分除ing以外，加入查找I’m singing while you’re dancing.时，它会匹配sing和danc。</p>
<p>(?&lt;=exp)也叫做<strong>零宽度正回顾后发断言</strong>，它能断言<strong>表达式exp后面的位置</strong>。比如(?&lt;=\bre)\w+\b会匹配以re开头的单词的后半部分除re以外，例如在查找reading a book时，它能匹配ading。</p>
<p>假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?&lt;=\d)\d{3})+\b，用它对1234567890进行查找时结果是234567890。<br><strong>说实话，上面这句话没看懂</strong>,不过还是可以分析：首先是分组里面的是匹配表达式\d后面的位置，然后是匹配三个数字(\d{3}),然后又是一个分组表示至少重复一次(+)，最后是就是结尾字符(\b)。<br>最后是是下面这个例子同时使用了这两种断言：(?&lt;=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。</p>
<h2 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h2><hr>
<p>负向零宽断言正好和零宽断言相反，也分为先行和回顾断言两种。<br>零宽度负预测先行断言(?!exp),意思是断言此位置的后面不能匹配表达式exp。例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字。\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。同理很好理解接下来的。</p>
<p>零宽度负回顾后发断言(?&lt;!exp),意思是断言此位置的前面不能匹配表达式exp，(?&lt;![a-z])\d{7}匹配前面不是小写字母的七位数字。我觉得以后每次看都可能需要思考一下，因为一下子有可能理解不了。</p>
<p>我们来看一下一个例子，<strong>\b\w<em>q[^u]\w</em>\b</strong>，这个表达式可以匹配一个不含换行符的单词，在前面已经知道任意数量的字母或数字是(\w<em>)，按正常情况下是可以的，但是在一些特殊情况下，例如Iraq,Benq，因为[^u]肯定会匹配一个字符，因此加入q是最后一个字符的话就会出现两个单词连在一起匹配结果。<br>但是使用了我们的负向零宽断言就不一样了，因为它完全不会消费任何字符，只匹配一个位置，因此可以使用这个表达式来轻松搞定：**\b\w</em>q(?!u)\w<em>\b*</em>,只要u前面不是q的话，那么表达式成立，同时匹配不成功</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><hr>
<p>我觉得直接看例子就可以看明白了，</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/27/python爬虫日记/" itemprop="url">
                  python爬虫日记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-07-27T16:26:12+08:00" content="2016-07-27">
              2016-07-27
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/27/python爬虫日记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/07/27/python爬虫日记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/27/学习javascript有感-2/" itemprop="url">
                  学习javascript有感-2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-07-27T10:51:44+08:00" content="2016-07-27">
              2016-07-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/27/学习javascript有感-2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/07/27/学习javascript有感-2/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="事件function"><a href="#事件function" class="headerlink" title="事件function"></a>事件function</h2><hr>
<p>事件也是面向对象开发中的一个环节，javascript的强大功能肯定少不了事件的实现。</p>
<h2 id="function作为参数"><a href="#function作为参数" class="headerlink" title="function作为参数"></a>function作为参数</h2><hr>
<p>首先看一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a,b,fn</span>)</span>&#123;</span><br><span class="line">	fn(a,b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a,b,fn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span>(fn) == <span class="string">"function"</span>)&#123;</span><br><span class="line">		fn(a,b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test(<span class="number">3</span>,<span class="number">4</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(a+b);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//输出7</span></span><br></pre></td></tr></table></figure></p>
<p>记得在调用test的时候直接用<strong>test(arguments);</strong>就可以了</p>
<h2 id="设计一个时间对象"><a href="#设计一个时间对象" class="headerlink" title="设计一个时间对象"></a>设计一个时间对象</h2><p>目标：设计一个事件对象。实现添加监听，移除监听，清空监听，发起事件信号。思路：1，定义一个对象，包含一个实例成员listeners，用于记录所有的监听者；2，为对象的原型增加，新增，删除，清空和执行四个成员。<br>整理好之后就可以具体来实现了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myEvent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.listeners = [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加一个监听者</span></span><br><span class="line">myEvent.prototype.addListener = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.listeners.push(fn)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//移除一个监听者</span></span><br><span class="line">myEvent.prototype.removeListener = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> index = <span class="keyword">this</span>.insteners.indexOf(fn);</span><br><span class="line">	<span class="keyword">this</span>.listeners.splice(index,<span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//清除所有监听者</span></span><br><span class="line">myEvent.prototype.clearListeners = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.listeners = [];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//发出执行信号，并告知所有监听者</span></span><br><span class="line">myEvent.prototype.raise = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> l = <span class="keyword">this</span>.listeners.length;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">		<span class="keyword">this</span>.listeners[i](e); <span class="comment">//执行所有监听方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me = <span class="keyword">new</span> myEvent();</span><br><span class="line">me.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">document</span>.write(<span class="string">"我是第一个监听者："</span> + e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">me.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">document</span>.write(<span class="string">"我是第二个监听者："</span> + e);</span><br><span class="line">&#125;);</span><br><span class="line">me.raise(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure></p>
<p>代码输出的结果是：<br>我是第一个监听者 : a<br>我是第二个监听者 : a</p>
<p>我先写出我开始明白的一些东西，一不小心google了一下，知道了<strong>push()</strong>的用法，直接调用w3c的解释：push() 方法可把它的参数顺序添加到 arrayObject 的尾部。它直接修改 arrayObject，而不是创建一个新的数组。push() 方法和 pop() 方法使用数组提供的先进后出栈的功能。<br>也就是可以不断在一开始的空集合listeners添加object，这也很好理解上一篇的其中一段代码的执行含义了。</p>
<p>另外就是移除一个监听者的成员方法里面的两段代码也需要解释一下，首先要科普一下indexOf和splice分别的用法。</p>
<blockquote>
<ul>
<li>indexOf(searchvalue,fromindex)，此方法可以返回字符串首次出现的位置，其中searchvalue表示要检索的字符串值，而fromindex表示从字符串的哪个位置开始检索，如果检索的字符串没有出现，则返回-1。</li>
<li>splice(index,howmany,item1,…..,itemX)，此方法可以从数组添加或者删除项目，然后返回被删除的项目。index表示添加或者删除项目的位置，使用附属可以从数组结尾处规定位置。howmany 必需。规定应该删除多少元素。如果设置为0则不进行删除操作，item1,…..,itemX分别表示想数组添加元素.<br>所以在上面的代码块中</li>
</ul>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/25/学习javascript有感/" itemprop="url">
                  学习javascript有感
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-07-25T16:14:04+08:00" content="2016-07-25">
              2016-07-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/25/学习javascript有感/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/07/25/学习javascript有感/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>基础的东西我就不想记在我的博客里面上了，大家也可以在w3c里面自己练习一下，我主要是为了记一下现在刚刚学习完javascript的思维方式，因为学好的东西一般情况下基础的东西会记得，但是总会得了新伤就忘记久痛，忘记以前学习的心得。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><hr>
<h3 id="javascript的try-catch语法"><a href="#javascript的try-catch语法" class="headerlink" title="javascript的try-catch语法"></a>javascript的try-catch语法</h3><p>在javasscript中，使用try-catch语句的用法：在try里面将可能出现抛出的错误做个判断，然后做出对应的throw信息，并会将这个信息传递给err这个变量，然后在catch(err)语句里面做相应的处理。</p>
<h3 id="javascript的原始对象"><a href="#javascript的原始对象" class="headerlink" title="javascript的原始对象"></a>javascript的原始对象</h3><p>javascript是一门面向对象的语言，因此我可以将很多知识和我现有知道的java语言相对比。在面向对象中，最重要的是封装。直接看代码<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var worker = new Object();</span><br><span class="line">worker.name = "tom";</span><br><span class="line">worker.age = 10;</span><br><span class="line">worker.isWorking = false;</span><br><span class="line">worker.startWork = function()&#123;</span><br><span class="line">	if(this.isWorking) return;</span><br><span class="line">    this.isWorking = true;</span><br><span class="line">&#125;;</span><br><span class="line">worker["position"] = "worker";</span><br><span class="line"></span><br><span class="line">document.write("Worker的名字是 : " + worker["name"]);</span><br><span class="line">worker.startWork();</span><br><span class="line">document.write("<span class="tag">&lt;<span class="name">br</span>/&gt;</span>Worker的职位是 : " + worker.position);</span><br></pre></td></tr></table></figure></p>
<p>上面这段代码输出的结果是：<br>    Worker的名字是 : tom<br>    Worker的职位是 : worker<br>再看一下另外一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> worker = &#123;</span><br><span class="line">        name : <span class="string">"John"</span>,</span><br><span class="line">        age : <span class="number">30</span>,</span><br><span class="line">        isWorking : <span class="literal">false</span>,</span><br><span class="line">        startWork : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">this</span>.isWorking)&#123;</span><br><span class="line">                <span class="keyword">this</span>.isWorking = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p>
<p>在上面的两段代码可以看出构建一个object和我们java是很不一样的，它们不需要再额外的声明一个变量来存储这个object的属性，另外和java一样的是也可以在实例里面添加字符，数字，布尔值甚至是一个方法的成员，这个特点在上面两段代码中都很明显的显示了出来。</p>
<p>在第一段代码中能发现创建属性的两种方式分别是<strong>实例名.成员名 = 内容</strong>,当然可以用<strong>实例名.[“成员名”] = 内容</strong>。而这里思想我觉得可以和java的map联系起来，就是通过键值对来存储属性，使用的时候javascript通过键解释对应的值。</p>
<p>不过认真看一下代码就知道，上面的单纯创建实例很呆板，仅仅是创建好一个可以吃的月饼，但是我们创建实例是为了方便我们后面的开发，所以这种方法肯定不提倡，我们应该创建以一个做月饼的模板，当相同的面团来的时候就可以直接用模板做好一个月饼，省去很多开发成本。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newHuman</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">    	name : name,</span><br><span class="line">        age : age,</span><br><span class="line">        sayHello : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        	<span class="built_in">document</span>.write(<span class="string">"Hello World! I'm "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h = newHuman(<span class="string">"jim"</span>,<span class="number">30</span>);</span><br><span class="line">h.sayHello(); <span class="comment">//输出结果是：Hello World! I'm jim</span></span><br></pre></td></tr></table></figure></p>
<p>这段代码声明了三个属性，分别是name，age，sayHello方法，最后实例化这个方法，调用里面的sayHello方法，当然在再外部使用实例好的h.age也是可以得。至于为什么要直接return才可以创建成员我就不知道了，用一句老话说应该是：javascript就规定这样。我试过在return外卖加this.iswork = false;或者在实例好newHuman之后添加h.iswork = false。最后还是输出underfined。</p>
<p>然后继续看下面一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">worker</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.isWorking = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">this</span>.startWork = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.isWorking) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">this</span>.isWorking = <span class="literal">true</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tom = <span class="keyword">new</span> worker(<span class="string">"tom"</span>, <span class="number">40</span>);</span><br><span class="line"><span class="keyword">var</span> jim = <span class="keyword">new</span> worker(<span class="string">"jim"</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(tom.startWork == jim.startWork);</span><br><span class="line"><span class="comment">//最终输出的结果是：false</span></span><br></pre></td></tr></table></figure></p>
<p>对于我来说，上面这段代码消除了我原来在上面的代码的疑问，因为这里没有return，可是依然可以访问到实例后的成员属性，不过我在上面一段代码中其实是用试过这样改的，但是输出的结果一样。<br>但是我们从最终的输出结果来看，可以知道最终实例好的tom和jim其实值得内存是不一样的，这样意味着当我们需要创建很多实例的时候，内存的开销会非常大。于是我们看下一段代码进行改善：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">worker</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.isWorking = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">worker.prototype.startWork = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>.isWorking) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">this</span>.isWorking = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tom = <span class="keyword">new</span> worker(<span class="string">"tom"</span>, <span class="number">40</span>);</span><br><span class="line"><span class="keyword">var</span> jim = <span class="keyword">new</span> worker(<span class="string">"jim"</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> html = <span class="string">"tom和jim两个实例的startWork方法是否共用内存 : "</span> </span><br><span class="line">				+ (tom.startWork == jim.startWork).toString();</span><br><span class="line"><span class="built_in">document</span>.write(html);</span><br></pre></td></tr></table></figure></p>
<p>run上面的代码的时候输出的结果是tom和jim两个实例的startWork方法是否共用内存 : true。这下两个不同实例的startwork是指向相同的地址了，说明了不同的实例共用了该方法。</p>
<p>在设计javascript的时候遵循下面两条规则<br>1，因为实例不同而不同的内容，用this关键字声明<br>2，无论实例怎样内容完全相同的成员，定义在prototype上</p>
<p>而上面第二条所说的prototype其实就是原型，<strong>任何类型都会有属于自己的原型，并且原型上定义的成员，可以在每个实例中引用，并且是共用的</strong>，其实我不太明白这句话，不过初步理解肯定是定义的成员能共用同一块内存。</p>
<p>然后对比相面的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.startWith = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> str.indexOf(str) == <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"abc"</span>;</span><br><span class="line"><span class="built_in">document</span>.write(str.startWith(<span class="string">"ab"</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.prototype.endWith = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> str.indexOf(str) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = <span class="string">"test"</span>;</span><br><span class="line"><span class="built_in">document</span>.write(test.endWith(<span class="string">"a"</span>));</span><br></pre></td></tr></table></figure></p>
<p>这里可以看出一些规律，首先是上面哪一段代码里面是worker.prototype.startWork通过使用new worker来创建一个实例，但是这里是String.prototype.endWith来创建的方法，自然就是使用String类来创建变量。当然把String改成Boolean的话，声明变量就只能用true和false了。</p>
<p>看了一天，总算是明白了这里的意思：就是javascript的成员定义是写在定义域外面的，这和我们java的不一样，因此尽管已经是定义好的String或者Data类型，我们依然可以使用javascript这种特殊的语法结构进行扩展和修改。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1，其实，写了上述那么多例子，应该能看出点什么？作为一名写java写了两年的小程序员，在学习javascript过程中我一直在想象这两门语言的不同之处和相同之处，其实这里我们可以把父function看作java的类，也就是javascript所说的对象，然后父function所嵌入的function就是我们一直都知道的方法这个概念了，只不过奇特的是javascript在设计的时候会遵循一些规则，其中一条就是定义内容相同的成员，要定义在外部的prototype上，所以才会看到如上面的代码这样把方法写出来。<br>语法结构可以概括为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(父<span class="function"><span class="keyword">function</span>).<span class="title">prototype</span>.(<span class="params">成员方法名字</span>) = <span class="title">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//此处编写代码逻辑</span></span><br><span class="line">	<span class="comment">//在此方法内部使用成员变量需要加关键字this</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>2，另外一种定义父类的方法就是直接通过var关键字定义一个实例对象，通过键值对来存储，存储类型可以是：String，boolean，Integer，function等基本类型。<br>语法结构：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里需要注意一些语法问题，例如一些标点符号的使用</span></span><br><span class="line"><span class="keyword">var</span> objName = &#123;</span><br><span class="line">	key1 : <span class="string">"String"</span>,</span><br><span class="line">	key2 : <span class="number">3</span>,</span><br><span class="line">	key3 : <span class="literal">false</span>,</span><br><span class="line">	key4 : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>关于javascript的继承我们同样有两种方法来实现，首先是对原始对象使用<strong>$.entend</strong>关键字，继承之后可以拥有父类对象也可以重写父类型还可以自定义自己的成员。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个工人</span></span><br><span class="line">    <span class="keyword">var</span> worker = &#123;</span><br><span class="line">        name : <span class="string">""</span>,</span><br><span class="line">        age : <span class="number">0</span>,</span><br><span class="line">        isWorking : <span class="literal">false</span>,</span><br><span class="line">        startWork : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//some code here</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//定义一个工头，工头本身也是工人，但他有一个额外的属性，用于记录他所管理的员工列表，并且可以指挥一名工人开工</span></span><br><span class="line">    <span class="keyword">var</span> leader = $.extend(worker,&#123;</span><br><span class="line">        workers : [],</span><br><span class="line">        callStart : <span class="function"><span class="keyword">function</span>(<span class="params">worker</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//指挥一名工人开工</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//此时的leader除了拥有name，age，isWorking，startWork这四项属性之外，还拥有workers和callStart成员。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="父类的构造函数调用"><a href="#父类的构造函数调用" class="headerlink" title="父类的构造函数调用"></a>父类的构造函数调用</h2><p>对于function创建的类型，其自身是无法进行$.extend的，这时候我就可以想到java的父类调用了，java是可以使用super关键字对于已经继承了父类进行构造函数的调用。而这里是使用：[function的名字].apply(this, arguments);其中这里的arguments是参数列表。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseClass</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.a = a;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aClass</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	baseClass.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> aClass(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">document</span>.write(test.a);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(test.b);</span><br><span class="line"><span class="comment">//输出1 2</span></span><br></pre></td></tr></table></figure></p>
<p>对于刚学javascript的我需要在开始的时候仔细整理一下我的思路：<br>首先是apply关键字，我可以把它看作是java中的super关键字，就好像是指针指向对应创建的构造函数的内存空间，相当于反射。<br>而通过baseClass.apply(this,arguments);相当于使用当前的实例和当前函数执行一次baseClass方法,这样看起来好像没有什么作用，仅仅是可以节省一些代码来调用另外一个函数。</p>
<p>直接继承：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">worker</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">worker.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">document</span>.write(<span class="string">"hello ! &lt;br/&gt;"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leader</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	worker.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line">leader.prototype = worker.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> l = <span class="keyword">new</span> leader(<span class="string">"jim"</span>);</span><br><span class="line">l.sayHello();</span><br><span class="line"><span class="comment">//输出 hello！</span></span><br></pre></td></tr></table></figure></p>
<p>而直接继承成员会有缺陷：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">worker</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.isWorking = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">worker.prototype.startWork = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>.isWorking) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">this</span>.isWorking = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leader</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">	worker.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">this</span>.workers = [];</span><br><span class="line">&#125;</span><br><span class="line">leader.prototype = worker.prototype;</span><br><span class="line">leader.prototype.startWork = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//重写工人的开始工作方法，工头开工时，下属工人也要开工</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.isWorking) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> workerLength = <span class="keyword">this</span>.workers.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; workerLength; i++)&#123;</span><br><span class="line">    	<span class="keyword">this</span>.workers[i].startWork();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tom = <span class="keyword">new</span> leader(<span class="string">"tom"</span>,<span class="number">40</span>);</span><br><span class="line"><span class="keyword">var</span> jim = <span class="keyword">new</span> worker(<span class="string">"jim"</span>,<span class="number">20</span>);</span><br><span class="line">tom.workers.push(jim);</span><br><span class="line">tom.startWork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> html = <span class="string">"tom和jim两个实例的startWork方法是否共用内存 : "</span> + (tom.startWork == jim.startWork).toString();</span><br><span class="line"><span class="built_in">document</span>.write(html);</span><br></pre></td></tr></table></figure></p>
<p>上面的代码其实我没有读太明白，我知道因为在leader中他新创建了一个空的workers集合，而他的父类没有workers集合，但是在startWork里面调用的isWorking里面的，因此会由于在worker里面找不到workers集合，会出现异常。呃，我只能这样理解不知道正不正确。</p>
<p>另外还有一点就是倒数第四句的<strong>tom.workers.push(jim);</strong>是什么意思，删掉之后也对程序没什么影响，我觉得学到后面才可以知道它的作用。另外经过证实我的理解可能是正确的是，我通过在worker中加入一句<strong>this.workers = [];</strong>然后程序就跑起来了，输出的结果是tom和jim两个实例的startWork方法是否共用内存 : true。</p>
<p>我们再看下一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">worker</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.isWorking = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">worker.prototype.startWork = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>.isWorking) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">this</span>.isWorking = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leader</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">	worker.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">this</span>.workers = [];</span><br><span class="line">&#125;</span><br><span class="line">leader.prototype = <span class="keyword">new</span> worker();	<span class="comment">//重点</span></span><br><span class="line">leader.prototype.startWork = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//重写工人的开始工作方法，工头开工时，下属工人也要开工</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.isWorking) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> workerLength = <span class="keyword">this</span>.workers.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; workerLength; i++)&#123;</span><br><span class="line">    	<span class="keyword">this</span>.workers[i].startWork();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tom = <span class="keyword">new</span> leader(<span class="string">"tom"</span>,<span class="number">40</span>);</span><br><span class="line"><span class="keyword">var</span> jim = <span class="keyword">new</span> worker(<span class="string">"jim"</span>,<span class="number">20</span>);</span><br><span class="line">tom.workers.push(jim);</span><br><span class="line">tom.startWork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> html = <span class="string">"tom和jim两个实例的startWork方法是否共用内存 : "</span> + (tom.startWork == jim.startWork).toString();</span><br><span class="line"><span class="built_in">document</span>.write(html);</span><br><span class="line"><span class="comment">//输出的结果是：tom和jim两个实例的startWork方法是否共用内存 : false</span></span><br></pre></td></tr></table></figure></p>
<p>对比上面哪一段代码，这段代码增加了一段<strong>leader.prototype = new worker();</strong>，我们先看一下其他代码和上面的一样，另外worker方法里面也没有对应的workers集合，再运行一下代码，可以运行，没有抛出异常。<br>另外看一下输出的结果也不是true，通过现象看本质，可以看到现在leader和worker对应的内存空间肯定不一样了。我们来听一下比较官方的解释：通过leader.prototype = new worker();这段代码相当于创建了一个worker实例，并将这个实例中的各个成员复制给leader的原型，这样一来对子类的修改仅仅是影响worker的实例，而不会影响worker的原型。</p>
<p>学完这些之后要好好分析一下上面的代码才可以，根据代码解释的顺序来分析；<br>首先是创建了一个worker父类方法，然后使用方法的规则创建一个内存共享的startWork成员方法，将新建的leader使用apply关键字继承worker，并且新创建一个workers集合。<br>然后使用leader.prototype = new worker();这段代码继承父类的副本实例对象，接下来就可以重写父类的startWork成员方法了，不过这里面写的一大段东西我都不太明白是什么意思<br>接下来就是实例化父类和子类了，事实证明，接下来的代码里面，tom.startWork();这段代码是没有用处的，感觉仅仅是个开关功能，不知道有没有执行到for循环，接着再下下面的代码就没什么可以分析的了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/20/nodeJS入门基础/" itemprop="url">
                  nodeJS入门基础
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-07-20T11:27:57+08:00" content="2016-07-20">
              2016-07-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/20/nodeJS入门基础/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/07/20/nodeJS入门基础/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是NodeJS？"><a href="#什么是NodeJS？" class="headerlink" title="什么是NodeJS？"></a>什么是NodeJS？</h2><p>Node是一个服务器端的javascript解释器,它将改变服务器应该如何工作的概念。它的目标是帮助程序员构建高度可伸缩的应用程序，编写能够处理数万条同时连接到一个（只有一个）物理机的连接代码。<br>Node解决并发连接最大数量的方法是：每个连接发射一个在 Node 引擎的进程中运行的事件，而不是为每个连接生成一个新的 OS 线程（并为其分配一些配套内存）。Node 声称它绝不会死锁，因为它根本不允许使用锁，它不会直接阻塞 I/O 调用。Node 还宣称，运行它的服务器能支持数万个并发连接。</p>
<p>在学习react-native的时候发现有些后备知识不太健全，于是按照学习入门的要求就来看了一下nodejs的入门，但是这里我就不详细说学习步骤了，网上有一大堆步骤，我只说我遇到的一些问题和解决办法</p>
<h2 id="有关函数传递"><a href="#有关函数传递" class="headerlink" title="有关函数传递"></a>有关函数传递</h2><hr>
<p>写好一个以http服务器的server之后，我们如果想要模块化这个功能，在其他js文件里面调用这个server模块的时候就要在对应的server结尾处添加一段代码；</p>
<h2 id="server-js"><a href="#server-js" class="headerlink" title="server.js"></a>server.js</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var http = require("http");</span><br><span class="line"></span><br><span class="line">function start() &#123;</span><br><span class="line">  function onRequest(request, response) &#123;</span><br><span class="line">    console.log("Request received.");</span><br><span class="line">    response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;);</span><br><span class="line">    response.write("Hello World");</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  http.createServer(onRequest).listen(8888);</span><br><span class="line">  console.log("Server has started.");</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br></pre></td></tr></table></figure>
<h2 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var server = require("./server");</span><br><span class="line"></span><br><span class="line">server.start();</span><br></pre></td></tr></table></figure>
<p>这里只需要关注一下server.js的function的名字和对应导出去的那个start方法。<br>我在测试的时候相应的改动了三处：</p>
<blockquote>
<p>修改function的start，改为starter，报错为在server.js中的ReferenceError: start is not defined，意思是引用错误，start方法未被定义。<br>修改了一下function的start为starter还有末尾的exports.start = start改为exports.start = starter,此时服务器正常启动<br>根据程序员的正常嗅觉可以知道这时候要改动的就是exports.starter = start为exports.starter = start，另外修改了index.js的server.start为server.starter,很明显这时候正常运行<br>通过自己的测试可以知道这里的引用对象是exports函数通过声明一个新的start变量来存储在server.js中的start方法，因此最后一句是赋值语句，呃，这个好像不说大家也知道。<br>最后在index中通过requie将函数传递进来，通过“函数.方法”方法来调用传递过来的方法。</p>
</blockquote>
<h2 id="入门第二天"><a href="#入门第二天" class="headerlink" title="入门第二天"></a>入门第二天</h2><hr>
<p>我开始学到函数式编程，也就是我们把一个函数当作是参数来传递，在我写好的index文件中，将router对象传递技进去，服务器随后可以调用这个对象的route函数。也就是不把函数看作是一个名词，而是一个动词。</p>
<p>这次新创建了一个requestHandlers的模块，并且对于每一个请求处理程序，添加一个占位用函数，并随后将函数导出：</p>
<h2 id="requestHandlers-js"><a href="#requestHandlers-js" class="headerlink" title="requestHandlers.js"></a>requestHandlers.js</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function start() &#123;</span><br><span class="line">  console.log("Request handler 'start' was called.");</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function upload() &#123;</span><br><span class="line">  console.log("Request handler 'upload' was called.");</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br><span class="line">exports.upload = upload;</span><br></pre></td></tr></table></figure>
<h2 id="index-js-1"><a href="#index-js-1" class="headerlink" title="index.js"></a>index.js</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var server = require("./server");</span><br><span class="line">var router = require("./router");</span><br><span class="line">var requestHandlers = require("./requestHandlers");</span><br><span class="line"></span><br><span class="line">var handle = &#123;&#125;</span><br><span class="line">handle["/"] = requestHandlers.start;</span><br><span class="line">handle["/start"] = requestHandlers.start;</span><br><span class="line">handle["/upload"] = requestHandlers.upload;</span><br><span class="line"></span><br><span class="line">server.start(router.route, handle);</span><br></pre></td></tr></table></figure>
<h2 id="server-js-1"><a href="#server-js-1" class="headerlink" title="server.js"></a>server.js</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var http = require("http");</span><br><span class="line">var url = require("url");</span><br><span class="line"></span><br><span class="line">function start(route, handle) &#123;</span><br><span class="line">  function onRequest(request, response) &#123;</span><br><span class="line">    var pathname = url.parse(request.url).pathname;</span><br><span class="line">    console.log("Request for " + pathname + " received.");</span><br><span class="line"></span><br><span class="line">    route(handle, pathname);</span><br><span class="line"></span><br><span class="line">    response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;);</span><br><span class="line">    response.write("Hello World");</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  http.createServer(onRequest).listen(8888);</span><br><span class="line">  console.log("Server has started.");</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br></pre></td></tr></table></figure>
<h2 id="route-js"><a href="#route-js" class="headerlink" title="route.js"></a>route.js</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function route(handle, pathname) &#123;</span><br><span class="line">  console.log("About to route a request for " + pathname);</span><br><span class="line">  if (typeof handle[pathname] === 'function') &#123;</span><br><span class="line">    handle[pathname]();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log("No request handler found for " + pathname);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.route = route;</span><br></pre></td></tr></table></figure>
<p>从上到下观察改动的对象和函数可以知道一些东西，例如，首先为了能低耦合的方式将对象注入到route函数中，我们需要将requestHandlers.js写好的两个函数导出去，外部调用。<br>然后是看到index.js，注意这里的handle是一个包装了请求处理程序的集合，我直接照搬书里的话，正如所见，将不同的url映射到相同的请求处理程序上是是很容易的：只要在对象中添加一个键为”/“的属性，对应requestHandlers.start即可，这样我们就可以干净简洁地配置/start和/的请求都交由start这一处理程序处理。<br>接着就是server.js，在start里面添加了一个新的参数，然后通过参数传入到route回调函数里面去，因此我们也要修改一下route函数。<br>route函数的代码我们可以这样来阅读，首先判断给定的路径对应的请求程序也就是这里的方法function是否存在，如果存在的话就直接调用相应的函数。这样一来就很好解释简洁流畅的形如handle<a href="">pathname</a>;的表达式了<br>也就是说，如果传进去的pathname是刚刚在index集合中某一个，就会触发对应的函数，我们在index可以把这些集合和我们安卓的map相关起来，就是通过键值对来解释对应的pathname和函数程序。</p>
<h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><hr>
<p>首先更改掉start请求处理程序，我们让它等待10秒之后再返回hello Start，由于javascript没有sleep的操作，所以只能自己创建一个方法。</p>
<h2 id="修改requestHandlers-js修改如下"><a href="#修改requestHandlers-js修改如下" class="headerlink" title="修改requestHandlers.js修改如下"></a>修改requestHandlers.js修改如下</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function start() &#123;</span><br><span class="line">  console.log("Request handler 'start' was called.");</span><br><span class="line"></span><br><span class="line">  function sleep(milliSeconds) &#123;</span><br><span class="line">    var startTime = new Date().getTime();</span><br><span class="line">    while (new Date().getTime() <span class="tag">&lt; <span class="attr">startTime</span> + <span class="attr">milliSeconds</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="attr">sleep</span>(<span class="attr">10000</span>);</span><br><span class="line">  <span class="attr">return</span> "<span class="attr">Hello</span> <span class="attr">Start</span>";</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">function</span> <span class="attr">upload</span>() &#123;</span><br><span class="line">  <span class="attr">console.log</span>("<span class="attr">Request</span> <span class="attr">handler</span> '<span class="attr">upload</span>' <span class="attr">was</span> <span class="attr">called.</span>");</span><br><span class="line">  <span class="attr">return</span> "<span class="attr">Hello</span> <span class="attr">Upload</span>";</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">exports.start</span> = <span class="attr">start</span>;</span><br><span class="line"><span class="attr">exports.upload</span> = <span class="attr">upload</span>;</span></span><br></pre></td></tr></table></figure>
<p>当我们单独打开<a href="http://localhost:8888/start和http://localhost:8888/upload的时候，按照程序的逻辑，start函数会先等待10秒，然后再返回hello" target="_blank" rel="external">http://localhost:8888/start和http://localhost:8888/upload的时候，按照程序的逻辑，start函数会先等待10秒，然后再返回hello</a> start。而upload则会立即返回。<br>但是当我们重启浏览器，然后开启两个窗口，分别输入上面的两个地址但是不要打开，现在“/start”按下回车，快速切换到第二个窗口“/upload”也按下回车，这里发生了点事情，/start URl花了10秒，/upload也花了10秒，这就非常奇怪了，到底为什么？<br>原因是start()包含了阻塞操作，node实行的是并行执行，也就是node在不增加额外线程的情况下，依然可以对人物进行并行处理，node是单线程的，通过<a href="http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/" target="_blank" rel="external">事件轮询</a>来实现并行操作，一个队列如果阻塞了之后就会导致线程被占用而后面需要处理的程序被阻塞。</p>
<p>为了尽可能的避免阻塞操作，我们需要使用非阻塞操作，将函数作为参数传递给其他需要花时间做处理的函数，在完成之后使用回调传回到主线程上。ok，开始初步更改：<br>还是更改requestHandlers.js<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var exec = require("child_process").exec;</span><br><span class="line"></span><br><span class="line">function start() &#123;</span><br><span class="line">  console.log("Request handler 'start' was called.");</span><br><span class="line">  var content = "empty";</span><br><span class="line"></span><br><span class="line">  exec("ls -lah", function (error, stdout, stderr) &#123;</span><br><span class="line">    content = stdout;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function upload() &#123;</span><br><span class="line">  console.log("Request handler 'upload' was called.");</span><br><span class="line">  return "Hello Upload";</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br><span class="line">exports.upload = upload;</span><br></pre></td></tr></table></figure></p>
<p>上述代码使用了一个叫做child_process的nodejs模块，使用它是为了实现一个非常简单的非阻塞操作：exec().它能做什么，它能使用node的一天shell指令来遍历当前目录下的所有文件(“ls -lah”)，当/startURl的时候将文件信息输出到浏览器中。<br>上述代码访问呢“<a href="http://localhost:8888/start”" target="_blank" rel="external">http://localhost:8888/start”</a> 的运行结果是只出现了一个empty，这时候很明显就是想到了新添加的exec()函数发挥作用了，有了它，我们可以在执行非常耗时的操作的时候无需等待，如果换成”/find”会更加明显，因为find/，一般情况下执行时间会非常久，但是这并不是我们想要的效果。<br>我们先来分析一下exec()函数的，在例子中，回调函数function (error, stdout, stderr)是作为第二个参数传递给exec()的匿名函数。当代码执行到exec()之后，node就立即执行了return content；而这个时候，content依旧是“empty”，因为传递给exec()的回调函数还没有执行到——因为exec()的操作是异步的。<br>所以尽管只要耗时稍微比较长的话，都会交给node在后天继续执行下去，但是函数却调到下一条代码了，那么要怎么才能将检索好的目录呈现给用户呢？</p>
<h3 id="用非阻塞的方式进行请求响应"><a href="#用非阻塞的方式进行请求响应" class="headerlink" title="用非阻塞的方式进行请求响应"></a>用非阻塞的方式进行请求响应</h3><p>鉴于上面那种只实现了将耗时的操作交给回调函数处理，但是处理好的结果却没有很好的呈现出来，因此我们需要其他的计划和解决方法。刚好，nodeJS就有一种实现方案：函数传递。<br>这种新的方式是通过和旧的方式将内容传递给服务器想比，我们采用将服务器传递给内容的方式。从实践的角度来看，就是将response对象（从回调函数onRequest（）获取）通过请求路由传递给处理程序。随后。处理程序就可以采用该对象上的函数来对请求做出响应。</p>
<h3 id="首先是server-js函数："><a href="#首先是server-js函数：" class="headerlink" title="首先是server.js函数："></a>首先是server.js函数：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var http = require("http");</span><br><span class="line">var url  = require("url");</span><br><span class="line"></span><br><span class="line">function start(route, handle)&#123;</span><br><span class="line">	function onRequest(request, response)&#123;</span><br><span class="line">		var pathname = url.parse(request.url).pathname;</span><br><span class="line">		console.log("Request for " + pathname + " received.");</span><br><span class="line">		</span><br><span class="line">		route(handle, pathname, response);</span><br><span class="line">	&#125;</span><br><span class="line">	http.createServer(onRequest).listen(8888);</span><br><span class="line">	console.log("Server has started.");</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br></pre></td></tr></table></figure>
<p>route.js<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function route(handle, pathname, response)&#123;</span><br><span class="line">	console.log("About to route a request for " + pathname);</span><br><span class="line">	if(typeof handle[pathname] == 'function')&#123;</span><br><span class="line">		handle[pathname](response);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		console.log("No request handler found for " + pathname);</span><br><span class="line">		response.writeHead(404,&#123;"Content-type":"text/plain"&#125;);</span><br><span class="line">		response.write("404 Not found");</span><br><span class="line">		response.end();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.route = route;</span><br></pre></td></tr></table></figure></p>
<p>最后是requestHandler.js函数<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var exec = require("child_process").exec;</span><br><span class="line"></span><br><span class="line">function start(response) &#123;</span><br><span class="line">  console.log("Request handler 'start' was called.");</span><br><span class="line"></span><br><span class="line">  exec("ls -lah", function (error, stdout, stderr) &#123;</span><br><span class="line">    response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;);</span><br><span class="line">    response.write(stdout);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function upload(response) &#123;</span><br><span class="line">  console.log("Request handler 'upload' was called.");</span><br><span class="line">  response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;);</span><br><span class="line">  response.write("Hello Upload");</span><br><span class="line">  response.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.start = start;</span><br><span class="line">exports.upload = upload;</span><br></pre></td></tr></table></figure></p>
<p>参考文章：[Node.js 究竟是什么？]{<a href="http://www.ibm.com/developerworks/cn/opensource/os-nodejs/index.html?ca=drs#icomments}" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/opensource/os-nodejs/index.html?ca=drs#icomments}</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/19/react-native学习笔记/" itemprop="url">
                  react-native学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-07-19T21:02:29+08:00" content="2016-07-19">
              2016-07-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/19/react-native学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/07/19/react-native学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先配置环境就配了两天才跑出来welcome to React Native（呃，我的图是盗来的[鬼脸.jpg]）<br><img src="http://vczero.github.io/react_native/1_1.png" alt="welcome to React native"></p>
<p>直接登陆官网按照步骤下载需要的nodeJS，React，还有python2，另外我是学安卓的，很早就开始用androidstudio了，所以直接俄就省了很多步骤，该下载的东西下载好之后就可以开始新建一个项目了</p>
<h2 id="AwesomePreject的创建"><a href="#AwesomePreject的创建" class="headerlink" title="AwesomePreject的创建"></a>AwesomePreject的创建</h2><p>这个项目的名字是直接根据官网提供来创建的，使用这几个命令行：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">react-native init AwesomeProject</span><br><span class="line">cd AwesomeProject</span><br><span class="line">react-native run-android</span><br></pre></td></tr></table></figure></p>
<p>前两步非常顺利就执行下来了，剩下的是第三步，开始出差错了。</p>
<h2 id="报错："><a href="#报错：" class="headerlink" title="报错："></a>报错：</h2><p>一开始报错是这样的：<br>    err(一串数字)：项目路径（一般直接用命令行创建的都会在C盘的windows/system32目录下）…ERROR:Unable to open file.<br>这个就非常蛋疼了，google上搜索一下，在stack overflow中给出的解释翻译过来就是说文件的目录路径太长了，window下规定最长文件的读取路径长度是255 个字符，然而项目的某一张安卓的资源图片刚好长度就超过了，这就非常尴尬了，我一开始采取的措施是直接更改文件夹的名字，当时有点头脑发热，这完全行不通啊！用脑袋想想也知道，路径是代码里面写好的，你改文件夹的名字有什么用。<br>然后我就开始第二个方案，我竟然把项目放在了一个含有中文的文件夹下，导致还是读取不了。<br>最后我直接将项目放在D盘下，不过听说直接放在C盘也可以，因为只要把路径的字符数减少就可以了。最后才React-native android-start之后就可以运行了，但是此时还是出现了下面的错误<br><img src="http://static.oschina.net/uploads/space/2015/1010/145457_0VIT_2320053.png" alt="红色报错提示"><br>出现这个错误的原因我不太清楚，不过我还是按照我的想法写下来我的理解<br>它当时建议的步骤是这样的，查看你的模拟器或者真机是否已经开启debug，然后检查一下接口是否真确连接，最后是调试的wifi必须在同一个局域网内，最后可以之后就重新start。<br>我当时按照这些之后根据官网的一句代码react-native start，虽然我不太懂这句代码的作用，不过根据官网的翻译应该是如果使用react-native run-android包没有被正确启动的时候就可以使用这段代码来运行<br>结果又报错了，说是端口被占用，本来应该使用8801端口的，又去网上找了一下修改native端口的方法，下面是在ubuntu上才去的命令行，没想到window也适用<br>参考：<a href="http://stackoverflow.com/questions/32572399/react-native-android-failed-to-load-js-bundle" target="_blank" rel="external">修改权限</a></p>
<p>最后的最后无意中重新启动了一次，然后竟然看到模拟器出现了新情况，那就是提示正在获取jscript，所以上面的我觉得大部分是废话，这句才是经典。原来是打包的时候出错了。</p>
<p>后面就继续根据官网的提示改动了一下代码，<strong>使用快捷方式直接在模拟器上双击两次R键，瞬间就刷新了</strong>。</p>
<p>最后就是我的小米3在react-native的调试中很明显控制台是有信息输出的，但是却只出现一片空白，而模拟器却能正常调试，解决方式是打开悬浮窗权限<br>以为小米默认是屏蔽悬浮窗权限的，方法：<a href="http://jingyan.baidu.com/article/f25ef25466c0fc482d1b824d.html" target="_blank" rel="external">打开小米悬浮窗权限</a><br>至此，react-native就配置成功了，如果刚好可以帮助到你，我将非常荣幸，如果没有帮上忙，那我也没办法。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/03/非静态代码块和静态代码块static/" itemprop="url">
                  非静态代码块和静态代码块static
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-06-03T13:14:45+08:00" content="2016-06-03">
              2016-06-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/03/非静态代码块和静态代码块static/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/06/03/非静态代码块和静态代码块static/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在复习java的时候，突然发现一个比较模糊的东西，就是static这个关键字，我不知道是不是我当时学的时候走神了，所以现在补回来。<br><em>本文参考：<a href="http://blog.csdn.net/qinde025/article/details/6825051" target="_blank" rel="external">java静态方法、非静态代码块{}、静态代码块static{} </a>,集合了自己的想法写成。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zues.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//从输出来看可以知道这段代码只执行了一次，不然在实例化线段之后会再打印多一次</span></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		a= <span class="number">10</span>;</span><br><span class="line">		System.out.println(<span class="string">"父类在静态代码块中执行a = "</span>+a);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//这个是非静态代码块，感觉有点奇怪因为第一次看到这样的写法，完全没有依靠任何对象的调用就可以了</span></span><br><span class="line">		&#123;</span><br><span class="line">			a=<span class="number">8</span>;</span><br><span class="line">			System.out.println(<span class="string">"父类在非静态中执行a = "</span>+a);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	Test2()&#123;</span><br><span class="line">		<span class="comment">//通过讨论，因为a = 10是类加载的时候就自动执行的，所以这里直接用类访问的a，是已经执行完static静态代码块但是还没执行非静态代码块的，所以只被赋值到a = 8这一步。</span></span><br><span class="line">		<span class="keyword">this</span>(<span class="string">"a在带参构造函数中的值："</span> + Test2.a);</span><br><span class="line">		System.out.println(a);<span class="comment">//然后这里会打印出8，是因为这时候已经初始化了实例，会执行到非静态代码块，结果证明非静态代码块的执行顺序优先于构造函数</span></span><br><span class="line">		System.out.println(<span class="string">"父类在无参数构造函数中的a="</span>+a);<span class="comment">//这里已经是执行了非静态代码块里面的代码，所以a被赋值为8了</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Test2(String n)&#123;</span><br><span class="line">		System.out.println(n);</span><br><span class="line">		System.out.println(a);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Test2 t = <span class="keyword">null</span>;</span><br><span class="line">		System.out.println(<span class="string">"--------我是条实例化前后之间的线段---------"</span>);</span><br><span class="line">		t = <span class="keyword">new</span> Test2();		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="打印出来的结果是："><a href="#打印出来的结果是：" class="headerlink" title="打印出来的结果是："></a>打印出来的结果是：</h4><pre><code>父类在静态代码块中执行a = 10
--------我是条实例化前后之间的线段---------
父类在非静态中执行a = 8
a在带参构造函数中的值：10
8
8
父类在无参数构造函数中的a=8
</code></pre><p>我套用我参考的文章的总结语：静态代码块是在类加载时自动执行的，非静态代码块是在创建对象时自动执行的代码，不创建对象不执行该类的非静态代码块。<br>我是因为不太懂来源博文的代码意义才写这篇博客的，另外关于更多static用法请自己折腾。<br>ok，本次心得就到这里。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/11/view的构造函数/" itemprop="url">
                  view的构造函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-05-11T12:27:14+08:00" content="2016-05-11">
              2016-05-11
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/11/view的构造函数/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/05/11/view的构造函数/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>主要是转载一篇文章，以自己的实力当前还写不出这样的文章，不说太多，直接上文章，<a href="http://blog.csdn.net/yuzhouxiang/article/details/6958017" target="_blank" rel="external"> android view构造函数研究</a></p>
<p>在这之前一直被view的构造函数弄糊涂了好多次，这次终于找到一篇好的博文介绍了，看了两遍还不是很懂，打算看第三遍顺便写个demo敲一下。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><hr>
<p>任意继承一个view，androidstudio会提醒你至少继承一个构造函数，下面是view的四个不同的构造函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">YourView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(context);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">YourView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(context, attrs);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">YourView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">YourView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>分别给每一个构造函数编号为y1,y2,y3,y4。</p>
<blockquote>
<p>首先y1是简单的构造函数，如果只是想动态定性的快速构建一个view的时候，而不使用额外的xml文件inflate的话，在代码中直接new一个view实例的时候，会调用第一个构造函数。<br>y2多了一个AttributeSet类型的参数，通过布局文件xml创建一个view时，这个参数会将xml里面设定的属性传递给构造函数，也就是说通过inflate的方法但是却没有实现y2的话就会报错，类似这个android.view.InflateException<br>重要的是y3，</p>
</blockquote>
<p>我的想法是这样的，为什么需要自定义view，就是希望能创造出一些比较合乎业务要求的布局，这时候如果单纯的height或者margin之类的单个不能实现的话，我们就有需要自己通过自定义style，创造出自己的命名空间，然后定义自己独有的一些值，通过代码的形式传到自定义view类里面，然后将传进来的attrs进行相应的操作，我试一下用相应的代码实现来验证我的想法</p>
<h2 id="自定义style"><a href="#自定义style" class="headerlink" title="自定义style"></a>自定义style</h2><p>可以在res/values下创建一个attrs.xml文件<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">"CustomView"</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--采用驼峰命名规则,可以随意命名,format是属性的单位--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"ourstyle"</span> <span class="attr">format</span>=<span class="string">"reference"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"atext"</span> <span class="attr">format</span>=<span class="string">"string"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，定义了两个属性，单位是format，format类型包括<br>    reference     引用<br>    color            颜色<br>    boolean       布尔值<br>    dimension   尺寸值<br>    float            浮点值<br>    integer        整型值<br>    string          字符串<br>    enum          枚举值</p>
<h3 id="怎么使用呢？"><a href="#怎么使用呢？" class="headerlink" title="怎么使用呢？"></a>怎么使用呢？</h3><p>首先我们可以看到布局文件中最大的viewgroup会有一个或者两个是xmlns开头的字段，其实这个是XML name space的缩写，明白抽象概念之后我们自己定义一个命名空间（name space）<br>首先参考这个：xmlns:android=”<a href="http://schemas.android.com/apk/res/android" target="_blank" rel="external">http://schemas.android.com/apk/res/android</a>“<br><em>xmlns</em>，这个就不说了，上面刚讲了是XML name space的缩写<br><em>android</em>，这个是命名空间的名称，可以随意写，因为你也可能看到有些命名为app，后面调用的时候会用到这个，建议用可记性强简短的单词，你可以把android改成其他字母，再随便使用一下android:layout_width=”match_parent”或者android:layout_height=”match_parent”，你会发现定义好attrs都失效了，然后把这个属性的名称改成你命名之后的名字，又正常了<br><em><a href="http://schemas.android.com/apk/res/android" target="_blank" rel="external">http://schemas.android.com/apk/res/android</a></em>，这个是androidstudio万能的书写方式，在stackoverflow中翻译得到的意思是主要用来标记一些重要的属性，例如：&lt;RelativeLayout不写成&lt;RelativeLayout：id ，还有android:layout_width为什么不写成layout_width，更准确的说算是校对吧。而在eclipse中一般会这样默认写xmlns:app=”<a href="http://schemas.android.com/apk/res/com.zues.demo&quot;，后面的com.zues.demoshi" target="_blank" rel="external">http://schemas.android.com/apk/res/com.zues.demo&quot;，后面的com.zues.demoshi</a> app的包名，google一下这段代码会发现，这段简单的代码后面隐藏了惊天大秘密，具体的探索我就只帮你找到我觉得比较好的一个博客了<a href="http://gejiaheng.github.io/2015/04/19/xml-namespace/" target="_blank" rel="external">XML namespace in Android</a></p>
<h3 id="怎么在自定义的view中拿到我们定义好的属性呢？"><a href="#怎么在自定义的view中拿到我们定义好的属性呢？" class="headerlink" title="怎么在自定义的view中拿到我们定义好的属性呢？"></a>怎么在自定义的view中拿到我们定义好的属性呢？</h3><p>通过context.obtainStyledAttributes将构造函数中的attrs进行解析出来,就可以拿到相对应的属性.(下面的mAttrs只是举例)<br>TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.MyView);<br>mColor = typedArray.getColor(R.styleable.MyView_roundColor, 0XFF00FF00);</p>
<h3 id="需要注意的一点是-在我们获取尺寸的时候有三个函数进行使用-我们来看看他们之间的区别"><a href="#需要注意的一点是-在我们获取尺寸的时候有三个函数进行使用-我们来看看他们之间的区别" class="headerlink" title="需要注意的一点是:在我们获取尺寸的时候有三个函数进行使用,我们来看看他们之间的区别."></a>需要注意的一点是:在我们获取尺寸的时候有三个函数进行使用,我们来看看他们之间的区别.</h3><p>getDimension()是基于当前DisplayMetrics进行转换，获取指定资源id对应的尺寸。文档里并没说这里返回的就是像素，要注意这个函数的返回值是float，像素肯定是int。<br>getDimensionPixelSize()与getDimension()功能类似，不同的是将结果转换为int，并且小数部分四舍五入。<br>getDimensionPixelOffset()与getDimension()功能类似，不同的是将结果转换为int，并且偏移转换（offset conversion，函数命名中的offset是这个意思）是直接截断小数位，即取整（其实就是把float强制转化为int，注意不是四舍五入哦）。<br>    由此可见，这三个函数返回的都是绝对尺寸，而不是相对尺寸（dp\sp等）。如果getDimension()返回结果是20.5f，那么getDimensionPixelSize()返回结果就是21，getDimensionPixelOffset()返回结果就是20。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/default_avatar.jpg"
               alt="漏雨" />
          <p class="site-author-name" itemprop="name">漏雨</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">41</span>
              <span class="site-state-item-name">Artikel</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">Kategorien</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">Tags</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">漏雨</span>
</div>

<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>





      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=0.5.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'greatzuesgithubio';
      var disqus_identifier = 'page/2/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  



  
  
  

  


</body>
</html>
